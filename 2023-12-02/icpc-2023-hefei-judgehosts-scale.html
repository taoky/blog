<!DOCTYPE html>
<html lang="zh">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Do Your Judgehosts Scale? 对 ICPC 2023 合肥站评测问题的分析</title>
  <meta name="description" content="在答应来合肥站帮忙的那天，我怎么都没有想到，赛后自己居然要花好几天时间分析 Linux 内核的问题。">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://blog.taoky.moe/2023-12-02/icpc-2023-hefei-judgehosts-scale.html">
  
  
  <link rel="alternate" type="application/rss+xml" title="taoky&#39;s blog" href="https://blog.taoky.moe/feed.xml">

  <link rel="stylesheet" href="/assets/typo.css">
<link rel="stylesheet" href="/assets/fonts.css">
<link rel="stylesheet" href="/assets/dark.css">

  <link href="/assets/fonts/bitter.css" rel="stylesheet">
  
  
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8N496PNK2G"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-8N496PNK2G');
    </script>
  


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">taoky's blog</a>

    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger">
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewbox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
          </svg>
        </span>
      </label>
      <div class="trigger">
        
        
        <a class="page-link" href="/about/">About</a>
        
        
        <a class="page-link" href="/archives/">Archives</a>
        
        
        <a class="page-link" href="/projects/">Projects</a>
        
        
        <a class="page-link" href="https://www.taoky.moe/TAsterisk">TA*</a>
        
        
        <a class="page-link" href="https://github.com/taoky">GitHub</a>
        
      </div>
    </nav>

  </div>

</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post typo" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Do Your Judgehosts Scale? 对 ICPC 2023 合肥站评测问题的分析</h1>
    
    <p class="post-meta"><time datetime="2023-12-02T06:10:00+00:00" itemprop="datePublished">Dec 2, 2023</time> •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/tech/">tech</a>
      
    
      
    
  


 •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/kernel/">kernel</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/debug/">debug</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/server/">server</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  
  <div class="user-toc">
    <h3>TOC | 目录</h3>
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-tldr">遇到的问题 tl;dr</a></li>
<li class="toc-entry toc-h2"><a href="#runguard">Runguard</a></li>
<li class="toc-entry toc-h2"><a href="#bisect">Bisect</a></li>
<li class="toc-entry toc-h2"><a href="#free_ipc">free_ipc()</a></li>
<li class="toc-entry toc-h2"><a href="#free_ipc-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-benchmark">free_ipc() 的性能提升 benchmark</a></li>
<li class="toc-entry toc-h2"><a href="#poor-mans-stack-profiler">Poor man’s stack profiler</a></li>
<li class="toc-entry toc-h2"><a href="#lock-stat">Lock stat</a></li>
<li class="toc-entry toc-h2"><a href="#debugging-with-printk--ktime_get">Debugging with… printk() + ktime_get()?</a></li>
<li class="toc-entry toc-h2"><a href="#%E6%8E%A8%E8%AE%BA">推论</a></li>
<li class="toc-entry toc-h2"><a href="#%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E8%87%AA%E5%B7%B1%E7%9A%84%E9%83%A8%E7%BD%B2">如何测试自己的部署？</a></li>
<li class="toc-entry toc-h2"><a href="#%E7%BB%93%E8%AE%BA">结论</a></li>
</ul>
  </div>
  

  <div class="post-content" itemprop="articleBody">
    <p>在答应来合肥站帮忙的那天，我怎么都没有想到，赛后自己居然要花好几天时间分析 Linux 内核的问题。</p>

<!--more-->

<p><strong>Disclaimer:</strong></p>

<ol>
  <li>以下内容均为个人分析的结果；</li>
  <li>关于 Kernel 的部分可能存在错误，欢迎评论指正。
<!-- markdownlint-disable MD010 -->
</li>
</ol>

<h2 id="遇到的问题-tldr">遇到的问题 tl;dr</h2>

<p>因为签到题太简单但测试点又太多，评测队列塞满了。后来删掉了一些测试点之后发现，开始出现很多提交解法没问题，但是被判定超时，并且特征全部都是 judgehost 上报的 Wall time（墙上时钟时间）远高于 CPU time。之后进行了大批量的重测，但是评测非常非常慢，直到蔡队 (<a href="https://github.com/cubercsl" class="user-mention">@cubercsl</a>) 把 Wall time 上限开到了 10s，评测结果才正确（虽然还是非常非常慢，但是至少能有一份正确的最终榜单）。</p>

<p>「评测机」是一台 2 CPU（CPU 为 Intel(R) Xeon(R) Gold 6133），每个 CPU 20 核心的服务器（包括 Web 服务器在内合计两台服务器，都是从几周前的南京站运过来的），Ubuntu 22.04 + Linux kernel 5.15。最开始开启了 21 个评测实例，后来发现队列阻塞，所以加到了 30 个。故障期间，评测机的 load 为评测实例的两倍，并且有很多 <code class="language-plaintext highlighter-rouge">runguard</code>（DOMjudge Judgehost 的评测程序，用于设置隔离等）处于 D 状态。</p>

<p>因为一些巧合，最开始以为是网口/网卡/网卡驱动的问题，但是周一拿到数据库分析之后发现，即使在以为插网线的 hack 之后，问题还是完全没有解决。我找了一台校内的 server，开了一个 32 核心的 KVM 虚拟机（宿主机 CPU 为 Intel(R) Xeon(R) Silver 4314，略差一些），按照文档装上 judgehost 开了 30 个 daemon，<code class="language-plaintext highlighter-rouge">ssh -R 12345:localhost:12345</code> 让它能连上我的笔记本的 DOMjudge，然后连着交了 114514 发：</p>

<pre><code class="language-fish"># fish
# 正式比赛中这么做很可能导致你的队伍被 DQ (disqualified)
for i in $(seq 1 114514); ~/Downloads/domjudge-8.2.2/submit/submit --url http://localhost:12345/ --contest hefei -y G.cpp; end
</code></pre>

<p>于是惊讶地发现问题可以复现（时间单位为秒）：</p>

<p><img src="/pictures/judgehost/cactus_1.png" alt="复现问题"></p>

<p>能复现就简单多了，至少不是硬件问题——然后因为提交实在太多了，还好我打了一个数据库的 btrfs 快照，不然我就得重新下数据库打包文件了。</p>

<h2 id="runguard">Runguard</h2>

<p>Runguard（<a href="https://github.com/DOMjudge/domjudge/blob/main/judge/runguard.c">https://github.com/DOMjudge/domjudge/blob/main/judge/runguard.c</a>）是一个 C 程序，用于设置隔离环境，然后执行选手提交的程序，程序结束之后统计时间、程序输出等信息。它的一些技术选型：</p>

<ul>
  <li>Chroot 用来隔离文件系统（以及允许我们直接用选手机的 rootfs 来执行程序，一定程度确保一致性）</li>
  <li>Cgroup 用来绑核（cpuset）、限制内存（memory）、统计 CPU 时间（cpuacct）</li>
  <li>
    <p>Unshare 用来隔离一些网络之类别的东西：</p>

    <div class="language-c highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="n">unshare</span><span class="p">(</span><span class="n">CLONE_FILES</span><span class="o">|</span><span class="n">CLONE_FS</span><span class="o">|</span><span class="n">CLONE_NEWIPC</span><span class="o">|</span><span class="n">CLONE_NEWNET</span><span class="o">|</span><span class="n">CLONE_NEWNS</span><span class="o">|</span><span class="n">CLONE_NEWUTS</span><span class="o">|</span><span class="n">CLONE_SYSVSEM</span><span class="p">);</span>
</code></pre></div>    </div>

    <p><!-- █████████████████████████████ --></p>
  </li>
</ul>

<!-- - ████████████████████████████████████████████████████████ -->

<p>它的 “Wall time” 是怎么计算的呢：</p>

<ul>
  <li>建好 cgroup 之后 <code class="language-plaintext highlighter-rouge">fork()</code>。</li>
  <li>父进程 <code class="language-plaintext highlighter-rouge">fork()</code> 之后 <code class="language-plaintext highlighter-rouge">gettimeofday()</code> 掐表开始，子进程 <code class="language-plaintext highlighter-rouge">setrestrictions()</code> 之后处理一下标准输入输出错误，然后就 execve。</li>
</ul>

<p>两者在记时开始之前<strong>没有同步</strong>，所以 Wall time 是大概率包含 <code class="language-plaintext highlighter-rouge">setrestrictions()</code> 的时间的，如果 <code class="language-plaintext highlighter-rouge">setrestrictions()</code> 太慢的话，甚至 CPU time 也可能把它算进去。既然选手程序本体没问题，那么问题很可能在 <code class="language-plaintext highlighter-rouge">setrestrictions()</code> 上。</p>

<p>在现场 <code class="language-plaintext highlighter-rouge">/proc/&lt;pid&gt;/stack</code> 看 D 的 <code class="language-plaintext highlighter-rouge">runguard</code> 栈的时候 <a href="https://github.com/iBug" class="user-mention">@iBug</a> 发现很多 runguard 都在 <code class="language-plaintext highlighter-rouge">openat</code>/<code class="language-plaintext highlighter-rouge">rmdir</code> 里面，以及还有一些 <code class="language-plaintext highlighter-rouge">cgroup</code> 相关的东西，那么首先怀疑是 <code class="language-plaintext highlighter-rouge">cgroup</code> 的问题。我把 runguard 里面 cgroup 禁用了之后重新编译，再交了 250 发，然后发现：</p>

<p>好了。</p>

<p>尽管没有绑核、没有 CPU time（但是可以直接 user + sys 所以问题不大）、没有内存限制，但是 Wall - CPU 的问题神秘消失了。</p>

<p>之后在开着 runguard cgroup 支持的情况下，我测试了 Ubuntu 22.04 仓库内的 Linux 6.2 内核——问题仍然存在，6.5 OEM 内核——问题消失了。</p>

<h2 id="bisect">Bisect</h2>

<p>事已至此，只能动手编译内核 bisect 了。花了大半天时间编译了十几份不同版本的内核，最后发现首个解决问题的 commit 是 <a href="https://github.com/torvalds/linux/commit/da27f796a832122ee533c7685438dad1c4e338dd">da27f796a832122ee533c7685438dad1c4e338dd</a>。</p>

<pre><code class="language-git">ipc,namespace: batch free ipc_namespace structures

Instead of waiting for an RCU grace period between each ipc_namespace
structure that is being freed, wait an RCU grace period for every batch
of ipc_namespace structures.

Thanks to Al Viro for the suggestion of the helper function.

This speeds up the run time of the test case that allocates ipc_namespaces
in a loop from 6 minutes, to a little over 1 second:

real	0m1.192s
user	0m0.038s
sys	0m1.152s

Signed-off-by: Rik van Riel &lt;riel@surriel.com&gt;
Reported-by: Chris Mason &lt;clm@meta.com&gt;
Tested-by: Giuseppe Scrivano &lt;gscrivan@redhat.com&gt;
Suggested-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;
Signed-off-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;
</code></pre>

<p>挺好的，除了看起来和 cgroup 毫无关系以外。但是似乎和 IPC namespace 有关系，联想到 runguard <code class="language-plaintext highlighter-rouge">unshare()</code> 给自己搞了个新的 IPC namespace，我把 <code class="language-plaintext highlighter-rouge">CLONE_NEWIPC</code> 和 <code class="language-plaintext highlighter-rouge">CLONE_SYSVSEM</code> 去掉之后（后者是否有关联不太清楚，但是既然都是 IPC 不如一起删了）：</p>

<p>也好了。</p>

<p>所以这个问题：</p>

<ul>
  <li>Linux 6.3「没问题」，Linux 6.2 以及 5.15 存在；</li>
  <li>去掉 runguard 里的 cgroup 可以「解决」问题；</li>
  <li>或者去掉 runguard 里的 IPC namespace 隔离也可以「解决」问题。</li>
</ul>

<p><img src="/pictures/judgehost/anon_ha.jpg" alt="Ha?"></p>

<p class="center"><em>我真的很想做这个表情</em></p>

<h2 id="free_ipc"><code class="language-plaintext highlighter-rouge">free_ipc()</code></h2>

<p>看似我们已经获得了解决评测问题的方法，但是原因却还完全没有弄清楚。在 <a href="https://elixir.bootlin.com/linux/latest/source">elixir</a> 上翻找一通，以及向 GPT-4 先生请教补习了一些 kernel 知识，然后终于可以解释这个 commit 做了什么了。</p>

<p>（以下代码均以 vanilla 5.15.129 为例）</p>

<p>首先 Linux kernel 有<a href="https://docs.kernel.org/core-api/workqueue.html">「工作队列」(workqueue)</a> 的机制，允许异步执行一些任务（提交的任务会被对应的 kworker 执行）。<code class="language-plaintext highlighter-rouge">free_ipc()</code> 是一个工作任务，从注释看，是因为 RCU 同步的开销比较大，阻塞住不太好：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * The work queue is used to avoid the cost of synchronize_rcu in kern_unmount.
 */</span>
<span class="k">static</span> <span class="nf">DECLARE_WORK</span><span class="p">(</span><span class="n">free_ipc_work</span><span class="p">,</span> <span class="n">free_ipc</span><span class="p">);</span>
</code></pre></div></div>

<p>其中 <a href="https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt">RCU</a> 是一种针对读多写少的同步机制，每次同步 <code class="language-plaintext highlighter-rouge">synchronize_rcu()</code> 会等待已经开始的 rcu read lock 都 unlock 之后再返回（也被称为 RCU grace period）。</p>

<p>这个工作任务会被 <code class="language-plaintext highlighter-rouge">put_ipc_ns()</code> 调度：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * put_ipc_ns - drop a reference to an ipc namespace.
 * @ns: the namespace to put
 *
 * If this is the last task in the namespace exiting, and
 * it is dropping the refcount to 0, then it can race with
 * a task in another ipc namespace but in a mounts namespace
 * which has this ipcns's mqueuefs mounted, doing some action
 * with one of the mqueuefs files.  That can raise the refcount.
 * So dropping the refcount, and raising the refcount when
 * accessing it through the VFS, are protected with mq_lock.
 *
 * (Clearly, a task raising the refcount on its own ipc_ns
 * needn't take mq_lock since it can't race with the last task
 * in the ipcns exiting).
 */</span>
<span class="kt">void</span> <span class="nf">put_ipc_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">refcount_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mq_clear_sbinfo</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">llist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">mnt_llist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_ipc_list</span><span class="p">))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_ipc_work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">free_ipc()</code> 实现如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="nf">LLIST_HEAD</span><span class="p">(</span><span class="n">free_ipc_list</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_ipc</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llist_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">llist_del_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_ipc_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">llist_for_each_entry_safe</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">mnt_llist</span><span class="p">)</span>
		<span class="n">free_ipc_ns</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">free_ipc_list</code> 是一个无锁链表。<code class="language-plaintext highlighter-rouge">llist_del_all()</code> 会把链表头置空，然后 <code class="language-plaintext highlighter-rouge">node</code> 就是原来的链表头。<code class="language-plaintext highlighter-rouge">llist_for_each_entry_safe()</code> 会遍历链表，由 <code class="language-plaintext highlighter-rouge">free_ipc_ns()</code> 实际处理对应的 IPC namespace。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">free_ipc_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mq_put_mnt() waits for a grace period as kern_unmount()
	 * uses synchronize_rcu().
	 */</span>
	<span class="n">mq_put_mnt</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">sem_exit_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">msg_exit_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">shm_exit_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

	<span class="n">dec_ipc_namespaces</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">ucounts</span><span class="p">);</span>
	<span class="n">put_user_ns</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">);</span>
	<span class="n">ns_free_inum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个 commit 处理部分与 <code class="language-plaintext highlighter-rouge">mq_put_mnt()</code> 这一部分有关，之前其调用：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ipc/mqueue.c</span>
<span class="kt">void</span> <span class="nf">mq_put_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kern_unmount</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">mq_mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// fs/namespace.c</span>
<span class="kt">void</span> <span class="nf">kern_unmount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* release long term mount so mount point can be released */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>	<span class="cm">/* yecchhh... */</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kern_unmount</span><span class="p">);</span>
</code></pre></div></div>

<p>因此可以发现，这里每个 IPC namespace 都需要：</p>

<ol>
  <li>置空 mnt_ns；</li>
  <li>等待 RCU grace period；</li>
  <li>mntput。</li>
</ol>

<p>这个 commit 做的事情就是不要 <code class="language-plaintext highlighter-rouge">kern_unmount()</code>，而是在 <code class="language-plaintext highlighter-rouge">free_ipc()</code> 里面先一次性全部置空 mnt_ns，然后只需要等待一次 RCU grace period，最后再过一遍 <code class="language-plaintext highlighter-rouge">free_ipc_ns()</code>。<code class="language-plaintext highlighter-rouge">free_ipc_ns()</code> 内部调用也从 <code class="language-plaintext highlighter-rouge">mq_put_mnt()</code> 改成直接 <code class="language-plaintext highlighter-rouge">mntput()</code>。</p>

<p>听起来是个很棒的性能优化，但是这和我们的问题有什么关系呢？</p>

<h2 id="free_ipc-的性能提升-benchmark">
<code class="language-plaintext highlighter-rouge">free_ipc()</code> 的性能提升 benchmark</h2>

<p>先让我们看看这个 commit 给 <code class="language-plaintext highlighter-rouge">free_ipc()</code> 带来了什么性能提升吧。幸运的是，著名的系统性能分析专家 Brendan Gregg <a href="https://github.com/brendangregg/bpf-perf-tools-book/blob/master/originals/Ch14_Kernel/workq.bt">写过一个分析 workqueue 中任务执行时间的 bpftrace 脚本</a>，因此不用麻烦我去翻 bpftrace 的文档了。</p>

<p>在 5.15 与 6.3 上运行，<code class="language-plaintext highlighter-rouge">free_ipc()</code> 结果如下：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 5.15
@us[free_ipc]: 
[32K, 64K)             1 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[64K, 128K)            0 |                                                    |
[128K, 256K)           0 |                                                    |
[256K, 512K)           0 |                                                    |
[512K, 1M)             1 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[1M, 2M)               1 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[2M, 4M)               0 |                                                    |
[4M, 8M)               1 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[8M, 16M)              2 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[16M, 32M)             1 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[32M, 64M)             0 |                                                    |
[64M, 128M)            1 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[128M, 256M)           0 |                                                    |
[256M, 512M)           1 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |

# 6.3.0
@us[free_ipc]: 
[8K, 16K)              2 |                                                    |
[16K, 32K)           115 |@                                                   |
[32K, 64K)          5109 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[64K, 128K)         1209 |@@@@@@@@@@@@                                        |
[128K, 256K)           1 |                                                    |
</code></pre></div></div>

<p>可以发现，5.15 上 <code class="language-plaintext highlighter-rouge">free_ipc()</code> 调用虽然不多，但是令人震惊地缓慢，最慢的竟然需要 256 到 512 秒才能执行完成（内核代码对放置在默认 <code class="language-plaintext highlighter-rouge">system_wq</code> 队列的要求是 “There are users which expect relatively short queue flush time. Don’t queue works which can run for too long.”）！6.3.0 上的就正常多了。除此之外，<code class="language-plaintext highlighter-rouge">css_release_work_fn()</code>, <code class="language-plaintext highlighter-rouge">css_killed_work_fn()</code>, <code class="language-plaintext highlighter-rouge">cgroup_bpf_release()</code> 这几个和 cgroup 有关的函数也出现了少量执行超过 1s 的任务（css = cgroup subsystem state）。</p>

<p>至少这说明了在大批量评测的场合，修复之前的 <code class="language-plaintext highlighter-rouge">free_ipc()</code> 本身确实存在一些性能问题（考虑到有大量创建了自己的 IPC namespace 的 runguard 进程不停被创建销毁）。But then? 这个工作队列照理是异步执行，为什么会影响到 runguard 子进程的 cgroup 呢？</p>

<h2 id="poor-mans-stack-profiler">Poor man’s stack profiler</h2>

<p>对 <code class="language-plaintext highlighter-rouge">runguard</code> 分析的一个难点是，它是每次评测都要运行的，但是它的执行由 judgedaemon 这个 PHP 程序决定，评测本身又不长，不太容易 attach。<a href="https://github.com/iBug" class="user-mention">@iBug</a> 帮我写了个简单的 shell:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>pid <span class="k">in</span> <span class="si">$(</span>ps aux | <span class="nb">awk</span> <span class="s1">'$8 == "D" &amp;&amp; $11 = "/home/taoky/domjudge/judgehost/bin/runguard" { print $2 }'</span><span class="si">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Stack for </span><span class="nv">$pid</span><span class="s2">"</span><span class="p">;</span> <span class="nb">cat</span> /proc/<span class="nv">$pid</span>/stack<span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p>然后微调一下，每两秒输出到文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>watch <span class="nt">-n</span> 2 <span class="nt">-d</span> <span class="s1">'DATE=$(date +%s); for pid in $(ps aux | awk '</span><span class="se">\'</span><span class="s1">'$8 == "D" &amp;&amp; $11 = "/home/taoky/domjudge/judgehost/bin/runguard" { print $2 }'</span><span class="se">\'</span><span class="s1">'); do echo -e "\nStack for $pid" &gt;&gt; stack/$DATE; sudo cat /proc/$pid/stack &gt;&gt; stack/$DATE; done'</span>
</code></pre></div></div>

<p>然后就能够看到 D 住的 runguard 到底卡哪里了，虽然不太完美，但是够用了。</p>

<p>拿到有问题和没问题的 stacks 信息，做一下简单的统计：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 修复前的最后一个 commit 的内核</span>
~/t/d/stack_lastbug&gt; rg cgroup | <span class="nb">wc
   </span>1781    3562   83949
~/t/d/stack_lastbug&gt; rg free_ipc | <span class="nb">wc
    </span>522    1044   19314
~/t/d/stack_lastbug&gt; rg css | <span class="nb">wc
   </span>1207    2414   56696
~/t/d/stack_lastbug&gt; rg openat | <span class="nb">wc
   </span>1113    2226   47827
~/t/d/stack_lastbug&gt; rg <span class="nb">rmdir</span> | <span class="nb">wc
    </span>553    1106   22354
<span class="c"># 修复后的第一个 commit 的内核</span>
~/t/d/stack-firstfix&gt; rg cgroup | <span class="nb">wc
      </span>3       6     137
~/t/d/stack-firstfix&gt; rg free_ipc | <span class="nb">wc
    </span>165     330    6105
~/t/d/stack-firstfix&gt; rg css | <span class="nb">wc
      </span>1       2      46
~/t/d/stack-firstfix&gt; rg openat | <span class="nb">wc
      </span>0       0       0
~/t/d/stack-firstfix&gt; rg <span class="nb">rmdir</span> | <span class="nb">wc
      </span>0       0       0
</code></pre></div></div>

<p>似乎还真有点关系。肉眼翻了一些输出，发现有另一个单词出现很频繁：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/t/d/stack_lastbug&gt; rg shrinker | <span class="nb">wc
    </span>451     902   21106
~/t/d/stack-firstfix&gt; rg shrinker | <span class="nb">wc
      </span>0       0       0
</code></pre></div></div>

<p>相关的函数包括 <code class="language-plaintext highlighter-rouge">prealloc_shrinker()</code>, <code class="language-plaintext highlighter-rouge">reparent_shrinker_deferred()</code>, <code class="language-plaintext highlighter-rouge">unregister_shrinker()</code>。第一、三个在 IPC namespace 创建/销毁的时候出现，第二个会被 <code class="language-plaintext highlighter-rouge">css_killed_work_fn()</code> 调用。看一下代码吧！</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">prealloc_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SHRINKER_MEMCG_AWARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">prealloc_memcg_shrinker</span><span class="p">(</span><span class="n">shrinker</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SHRINKER_MEMCG_AWARE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_deferred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SHRINKER_NUMA_AWARE</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">*=</span> <span class="n">nr_node_ids</span><span class="p">;</span>

	<span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_deferred</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_deferred</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reparent_shrinker_deferred</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">shrinker_info</span> <span class="o">*</span><span class="n">child_info</span><span class="p">,</span> <span class="o">*</span><span class="n">parent_info</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">parent_mem_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>

	<span class="cm">/* Prevent from concurrent shrinker_info expand */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
	<span class="n">for_each_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">child_info</span> <span class="o">=</span> <span class="n">shrinker_info_protected</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="n">parent_info</span> <span class="o">=</span> <span class="n">shrinker_info_protected</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shrinker_nr_max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_info</span><span class="o">-&gt;</span><span class="n">nr_deferred</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_info</span><span class="o">-&gt;</span><span class="n">nr_deferred</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unregister_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SHRINKER_REGISTERED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SHRINKER_REGISTERED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SHRINKER_MEMCG_AWARE</span><span class="p">)</span>
		<span class="n">unregister_memcg_shrinker</span><span class="p">(</span><span class="n">shrinker</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_deferred</span><span class="p">);</span>
	<span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">nr_deferred</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_shrinker</span><span class="p">);</span>
</code></pre></div></div>

<p>有一些端倪：找到了一个全局的读写锁（信号量）<code class="language-plaintext highlighter-rouge">shrinker_rwsem</code>。而 <code class="language-plaintext highlighter-rouge">prealloc_shrinker()</code> 调用的 <code class="language-plaintext highlighter-rouge">prealloc_memcg_shrinker()</code> 也用到了这个信号量：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">prealloc_memcg_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
	<span class="cm">/* This may call shrinker, so it must use down_read_trylock() */</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">idr_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_idr</span><span class="p">,</span> <span class="n">shrinker</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">shrinker_nr_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">expand_shrinker_info</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>搞不好时间都花在了锁上头，而且这个锁还是全局的。</p>

<p>在 cgroup 这里，也有一些有趣的东西，不少 cgroup 函数都需要获取 <code class="language-plaintext highlighter-rouge">cgroup_mutex</code>，比如说上面我们提到的 <code class="language-plaintext highlighter-rouge">css_killed_work_fn()</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * This is called when the refcnt of a css is confirmed to be killed.
 * css_tryget_online() is now guaranteed to fail.  Tell the subsystem to
 * initiate destruction and put the css ref from kill_css().
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">css_killed_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span><span class="p">,</span> <span class="n">destroy_work</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">offline_css</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
		<span class="n">css_put</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
		<span class="cm">/* @css can't go away while we're holding cgroup_mutex */</span>
		<span class="n">css</span> <span class="o">=</span> <span class="n">css</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">css</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">online_cnt</span><span class="p">));</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgroup_mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这把 mutex 锁同样也是全局的。难道是锁导致的问题？</p>

<h2 id="lock-stat">Lock stat</h2>

<p>好消息：<a href="https://docs.kernel.org/locking/lockstat.html">Kernel 支持统计每个锁的信息</a>，包括等待锁的时间、持有锁的时间等等；</p>

<p>坏消息：要重新编译内核。</p>

<p>不过反正我都编译了十几次了，再来几次也无妨。然后和上面一样，每两秒读一下 <code class="language-plaintext highlighter-rouge">/proc/lock_stat</code> 的内容记录下来。</p>

<p>选一个高峰期的统计数据：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class name    con-bounces    contentions   waittime-min   waittime-max waittime-total   waittime-avg    acq-bounces   acquisitions   holdtime-min   holdtime-max holdtime-total   holdtime-avg

shrinker_rwsem-W:          3995           5539           0.12      826880.50   474904067.23       85738.23         100759         156706           0.00      827284.22    73644524.74         469.95
shrinker_rwsem-R:           222            227           0.36      604864.05    47812995.44      210629.94          39633          42040           0.57         544.72     3316088.16          78.88
----------------
    shrinker_rwsem           1753          [&lt;00000000c82e9511&gt;] __prealloc_shrinker+0x74/0x360
    shrinker_rwsem            341          [&lt;000000009fa4c964&gt;] unregister_shrinker+0x20/0x90
    shrinker_rwsem           3383          [&lt;00000000c42b3549&gt;] register_shrinker_prepared+0x1c/0x70
    shrinker_rwsem             62          [&lt;0000000032cb78dd&gt;] alloc_shrinker_info+0x1a/0x110
----------------
    shrinker_rwsem           3852          [&lt;00000000c82e9511&gt;] __prealloc_shrinker+0x74/0x360
    shrinker_rwsem           1604          [&lt;00000000fbba4669&gt;] reparent_shrinker_deferred+0x28/0x100
    shrinker_rwsem            239          [&lt;0000000032cb78dd&gt;] alloc_shrinker_info+0x1a/0x110
    shrinker_rwsem             18          [&lt;000000009fa4c964&gt;] unregister_shrinker+0x20/0x90

cgroup_mutex:        346315         355424           0.40     1017647.63 40646408006.90      114360.34         922305        1130556           0.00      685445.13  2132487536.75        1886.23
------------
cgroup_mutex         116559          [&lt;000000000a638515&gt;] cgroup_kn_lock_live+0x4d/0x140
cgroup_mutex          29751          [&lt;00000000c1655a73&gt;] proc_cgroup_show+0x4a/0x2d0
cgroup_mutex          54064          [&lt;00000000fe36961a&gt;] css_release_work_fn+0x24/0x260
cgroup_mutex          98304          [&lt;00000000f076cd76&gt;] cgroup_bpf_release+0x4d/0x330
------------
cgroup_mutex         191675          [&lt;000000000a638515&gt;] cgroup_kn_lock_live+0x4d/0x140
cgroup_mutex         160964          [&lt;00000000fa2cc618&gt;] css_killed_work_fn+0x19/0x150
cgroup_mutex           2401          [&lt;00000000fe36961a&gt;] css_release_work_fn+0x24/0x260
cgroup_mutex            326          [&lt;00000000c1655a73&gt;] proc_cgroup_show+0x4a/0x2d0
</code></pre></div></div>

<p>得到：</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">shrinker_rwsem</code>
    <ul>
      <li>写锁最大等待时间 826880us，最大持有时间 827284us；</li>
      <li>读锁最大等待时间 604864us，最大持有时间 545us；</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">cgroup_mutex</code>
    <ul>
      <li>最大等待时间 1017648us，最大持有时间 685445us。</li>
    </ul>
  </li>
</ul>

<p>因此可以确定是锁（特别是 <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 写锁）导致的问题了。</p>

<h2 id="debugging-with-printk--ktime_get">Debugging with… <code class="language-plaintext highlighter-rouge">printk() + ktime_get()</code>?</h2>

<p>用 BPF 应该可以实现任意内核代码的高效时间统计，但是因为调试符号打 deb 实在太慢了，所以我没打，然后就也不知道 kprobe 应该放哪里，所以最终还是采用了最原始的调试方案：<code class="language-plaintext highlighter-rouge">printk()</code>，然后用 <code class="language-plaintext highlighter-rouge">ktime_get()</code> 获取时间。可能有一些 overhead 吧——大概会有几 us？</p>

<p><code class="language-plaintext highlighter-rouge">mm/vmscan.c</code> 中需要写锁的有这么几个函数：<code class="language-plaintext highlighter-rouge">prealloc_memcg_shrinker()</code>, <code class="language-plaintext highlighter-rouge">alloc_shrinker_info()</code>, <code class="language-plaintext highlighter-rouge">free_prealloced_shrinker()</code>, <code class="language-plaintext highlighter-rouge">register_shrinker_prepared()</code> 和 <code class="language-plaintext highlighter-rouge">unregister_shrinker()</code>。看一下 stack 记录里面的几位出场嘉宾：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> rg shrinker | <span class="nb">cut</span> <span class="nt">--delimiter</span><span class="o">=</span><span class="s2">" "</span> <span class="nt">-f2</span> | <span class="nb">cut</span> <span class="nt">--delimiter</span><span class="o">=</span><span class="s2">"+"</span> <span class="nt">-f1</span> | <span class="nb">sort</span> | <span class="nb">uniq</span> <span class="nt">-c</span>
      3 alloc_shrinker_info
    183 __prealloc_shrinker
    183 prealloc_shrinker
     34 reparent_shrinker_deferred
     48 unregister_shrinker
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">alloc_shrinker_info()</code> 出镜率实在太低了，所以就先不管了。<code class="language-plaintext highlighter-rouge">reparent_shrinker_deferred()</code> 拿的是读锁，而 <code class="language-plaintext highlighter-rouge">unregister_shrinker()</code> 确实是写锁，但是观察实现发现唯一可能花一点点时间的是它调用的 <code class="language-plaintext highlighter-rouge">unregister_memcg_shrinker()</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_memcg_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrinker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">shrinker</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>

	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是 IDR 好歹是个 radix tree 变种，要是删个元素就要几百毫秒的话也实在说不过去（当然，我加过，然后发现它的执行时间根本不可能达到百毫秒的量级，以及高峰期 <code class="language-plaintext highlighter-rouge">shrinker_idr</code> 看起来数量级在上万左右）。</p>

<p>问题只可能在 <code class="language-plaintext highlighter-rouge">prealloc_memcg_shrinker()</code> 上面。IDR 分配和删除也不太可能占用那么多时间，因此给 <code class="language-plaintext highlighter-rouge">expand_shrinker_info()</code> 加了个 <code class="language-plaintext highlighter-rouge">printk()</code>：</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@@ -379,10 +385,14 @@</span> static int prealloc_memcg_shrinker(struct shrinker *shrinker)
                goto unlock;
 
        if (id &gt;= shrinker_nr_max) {
<span class="gi">+               ktime_t start, end;
+               start = ktime_get();
</span>                if (expand_shrinker_info(id)) {
                        idr_remove(&amp;shrinker_idr, id);
                        goto unlock;
                }
<span class="gi">+               end = ktime_get();
+               printk(KERN_INFO "expand_shrinker_info taken %lld ns\n", ktime_to_ns(ktime_sub(end, start)));
</span>        }
        shrinker-&gt;id = id;
        ret = 0;
</code></pre></div></div>

<p>（<code class="language-plaintext highlighter-rouge">goto unlock</code> 在测试中没有出现，所以偷懒了）</p>

<p>然后编译，重启，交一堆评测，结束之后收 kern.log，确实有慢到离谱的：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Nov 29 18:35:12 cactus kernel: [ 1494.674610] expand_shrinker_info taken 476731026 ns
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">expand_shrinker_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_nr_max</span> <span class="o">=</span> <span class="n">new_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">map_size</span><span class="p">,</span> <span class="n">defer_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_map_size</span><span class="p">,</span> <span class="n">old_defer_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_expand</span><span class="p">(</span><span class="n">new_nr_max</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_mem_cgroup</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shrinker_rwsem</span><span class="p">);</span>

	<span class="n">map_size</span> <span class="o">=</span> <span class="n">shrinker_map_size</span><span class="p">(</span><span class="n">new_nr_max</span><span class="p">);</span>
	<span class="n">defer_size</span> <span class="o">=</span> <span class="n">shrinker_defer_size</span><span class="p">(</span><span class="n">new_nr_max</span><span class="p">);</span>
	<span class="n">old_map_size</span> <span class="o">=</span> <span class="n">shrinker_map_size</span><span class="p">(</span><span class="n">shrinker_nr_max</span><span class="p">);</span>
	<span class="n">old_defer_size</span> <span class="o">=</span> <span class="n">shrinker_defer_size</span><span class="p">(</span><span class="n">shrinker_nr_max</span><span class="p">);</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_iter</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">expand_one_shrinker_info</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">map_size</span><span class="p">,</span> <span class="n">defer_size</span><span class="p">,</span>
					       <span class="n">old_map_size</span><span class="p">,</span> <span class="n">old_defer_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem_cgroup_iter_break</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_iter</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">shrinker_nr_max</span> <span class="o">=</span> <span class="n">new_nr_max</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>嫌疑最大的就是 do-while 了。如法炮制对每次迭代输出，然后写个脚本统计一下时间 (ns) 和前十名：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>19520: 702339350, max: 3940353, cnt: 9026, avg: 77812.91269665411
18368: 639621126, max: 744031, cnt: 8916, avg: 71738.57402422611
20544: 635646321, max: 802928, cnt: 9128, avg: 69636.97644609991
20416: 631049831, max: 7987415, cnt: 9032, avg: 69868.22752435783
19328: 628072921, max: 11967237, cnt: 8870, avg: 70808.67204058624
18496: 614502461, max: 839398, cnt: 8792, avg: 69893.36453594177
19904: 611960697, max: 7229538, cnt: 9041, avg: 67687.2798363013
18112: 608502773, max: 1009415, cnt: 8535, avg: 71294.99390743996
19456: 599951989, max: 12143250, cnt: 8965, avg: 66921.582710541
19264: 592053029, max: 12948429, cnt: 8803, avg: 67255.8251732364
</code></pre></div></div>

<p>对比 commit 之后的内核的数据：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>64: 206006, max: 9337, cnt: 113, avg: 1823.0619469026549
</code></pre></div></div>

<p>（只在最开始有一次，后面就没有再 expand 过了）</p>

<p>可以发现：</p>

<ul>
  <li>循环次数多了一个数量级（因为 cgroup 被锁卡着很难清理）；</li>
  <li>每次循环时间平均也多了一个数量级（可能是高负载导致的）。</li>
</ul>

<h2 id="推论">推论</h2>

<p>合计用了两天半时间，不停看代码、测试，最后我的推论是：</p>

<ul>
  <li>大量的评测导致大量的 runguard 进程被创建和销毁；</li>
  <li>销毁的 runguard 进程的 IPC namespace 也要销毁，但是因为内核的问题，每一个都要全局同步 RCU，销毁速度非常慢；每个销毁都需要获取 <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 写锁 (<code class="language-plaintext highlighter-rouge">unregister_shrinker</code>)；</li>
  <li>runguard 进程的 cgroup 也需要清理，对应的 cgroup subsystem state 的销毁工作的一部分给了 <code class="language-plaintext highlighter-rouge">css_killed_work_fn()</code>，它同时需要 <code class="language-plaintext highlighter-rouge">cgroup_mutex</code> 锁以及 <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 读锁 (<code class="language-plaintext highlighter-rouge">reparent_shrinker_deferred</code>)；</li>
  <li>因为销毁很慢，因此 IDR 里面分不出老的不再使用的 ID，只能分出新的，因此 <code class="language-plaintext highlighter-rouge">expand_shrinker_info()</code> 会被频繁执行，它的执行速度和当前拥有的（还没有销毁的）memory cgroup 数量正相关；</li>
  <li>随着时间推移，负载打满，<code class="language-plaintext highlighter-rouge">expand_shrinker_info()</code> 的执行时间会越来越长（在有很多核心的服务器上可能更显著，因为 <code class="language-plaintext highlighter-rouge">expand_one_shrinker_info()</code> 的执行时间和系统核心数量是线性关系），最终导致 <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 写锁释放缓慢，而 <code class="language-plaintext highlighter-rouge">cgroup_mutex</code> 也因此释放缓慢（拿不到 <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 的读锁），memory cgroup 也随之增多（但是不会无限增长，因为创建也需要 <code class="language-plaintext highlighter-rouge">cgroup_mutex</code>），推动了这个恶性循环；
    <ul>
      <li>现场的配置可能也有一些问题：最开始开启的评测 instance 是 0 到 20，但是 NUMA 的情况下绝大部分的评测 worker 都会挤在一个 CPU 上面。但是即使 NUMA 分配正确，也最多只会推迟问题，在高负载 45min 以上的情况下很可能还会发生。</li>
    </ul>
  </li>
  <li>cgroup 操作迟迟无法结束，如果发生在 Wall time 记时外，那么不会在 DOMjudge 页面上表现出来，但是评测时间会显著增长；如果发生在 Wall time 记时内，表现即为 Wall time » CPU time。如果设置的 Wall time 上限比较小，那么就会直接 TLE，即使上限比较大，也会导致评测时间显著增长。</li>
  <li>进入到了无法挽回的局面（即使重启机器，在这段时间的评测堆积也肯定会再次导致这个问题）。</li>
  <li>现场唯一能做的事情就是忍受慢速评测，提高 Wall time 限制（或者我穿越回当天，说服所有人升级内核或者关闭 IPC 隔离）。当场发现问题根源是<strong>不可能</strong>的（加服务器也不可能，因为需要保证型号一致，否则题目测试点的时间限制就不准确了）。
    <ul>
      <li>即使现场发现了 cgroup 可能有问题，因为需要 cgroup 限制内存使用，所以从 runguard 中去掉 cgroup 的使用也是无法接受的。</li>
    </ul>
  </li>
  <li>如果这么看，这个 commit 可能没有解决本质问题，在这个问题上卡顿的可能性仍然存在（只是概率低得多、过程更加缓慢因此可以接受了而已）。
    <ul>
      <li>我自己测试是偶尔还会出现一批进程 D 的情况，但是出现频率很低，跑比较长的时候 load 也只是略高于 worker 的数量。</li>
      <li>以及，其他的评测系统，只要每个评测点都创建一个新环境，并且用到 cgroup 和 unshare IPC 的（包括容器），都可能有这个问题。</li>
    </ul>
  </li>
  <li>如何彻底在内核中修复这个问题？<strong>我不知道。</strong>
    <ul>
      <li>字节跳动的 Qi Zheng 在今年初 <a href="https://lwn.net/ml/linux-kernel/20230223132725.11685-1-zhengqi.arch@bytedance.com/">[PATCH v2 0/7] make slab shrink lockless</a> 中提及了 <code class="language-plaintext highlighter-rouge">expand_shrinker_info()</code> 可能导致 <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 写锁被占用时间太长的问题，但是对应的 patch 合入之后因为新的性能问题又被 <a href="https://lwn.net/ml/linux-kernel/20230609081518.3039120-1-qi.zheng@linux.dev/">revert</a>，<a href="https://lwn.net/ml/linux-kernel/20230911094444.68966-1-zhengqi.arch@bytedance.com/">之后的新补丁</a>从我阅读代码来看，似乎锁仍然存在，上面提到的两个地方仍然有可能要抢锁（<code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 变成了 <code class="language-plaintext highlighter-rouge">shrinker_mutex</code>，因为补丁修改后 <code class="language-plaintext highlighter-rouge">reparent_shrinker_deferred()</code> 是唯一需要读锁的地方，而它又已知有 <code class="language-plaintext highlighter-rouge">cgroup_mutex</code>，所以变成了 <code class="language-plaintext highlighter-rouge">shrinker_mutex</code>）。</li>
    </ul>
  </li>
</ul>

<h2 id="如何测试自己的部署">如何测试自己的部署？</h2>

<p>我修改出了一个独立的版本，不需要部署 DOMjudge web 即可测试：<a href="https://github.com/taoky/judgescale">https://github.com/taoky/judgescale</a>。同时它会将 Wall - CPU 的时间差和总测评时间记录，方便在 DOMjudge 中预估、设置合理的 Wall time limit。</p>

<p>在本次的评测机上测试不间断同时进行 21 个评测，在全速评测不到 25 分钟内（从 uptime 2h 开始测试），就出现了此次问题的症状（评测监管进程 D，load 大于等于开启任务数量的两倍）：</p>

<p><img src="/pictures/judgehost/result1.png" alt="Result 1"></p>

<p>在安装 Linux 6.3.0 内核包后，相同条件运行接近 1h，1 分钟最高 load 在 30：</p>

<p><img src="/pictures/judgehost/result2.png" alt="Result 2"></p>

<p>（在压测中途安装了 netdata）：</p>

<p><img src="/pictures/judgehost/result2-netdata.png" alt="Result 2 load shown in netdata"></p>

<p>此外，测试时发现该服务器的内核（5.15 和 6.3）<strong>仅会在系统负载高的时候</strong>不停输出 “enoX speed is unknown, defaulting to 1000” 的信息（所以赛前也没人发现网卡的问题），从源代码看相关信息是 <code class="language-plaintext highlighter-rouge">ib_core</code> 输出的（<code class="language-plaintext highlighter-rouge">i40e</code> -&gt; <code class="language-plaintext highlighter-rouge">irdma</code> -&gt; <code class="language-plaintext highlighter-rouge">ib_core</code>），但是调试条件有限，因此其具体原因仍然不明。手动禁用 <code class="language-plaintext highlighter-rouge">irdma</code> 重启后就不会再出现这个问题了。处理后再测试了两个小时，Linux 6.3.0 内核下 21 个评测 worker load 稳定在 20 到 25，Wall - CPU 时间的值不超过 0.25s，考虑到在不超过 Wall time limit 情况下判断 TLE 是按照 CPU 时间为标准的，内核更新到 6.3 或以上之后应当就足以应对比赛环境了。</p>

<p><strong>Update 1 (2023/12/05):</strong> 如果只修改 runguard，让父子进程同步保证 <code class="language-plaintext highlighter-rouge">setrestrictions()</code> 不计入 Wall time 能解决问题吗？<a href="https://github.com/taoky/domjudge/commit/56d18b8a71183abf376a51f398c9752ffc0f7f00">修改了一下 runguard 代码</a>之后测试，发现问题仍然可能存在：</p>

<p><img src="/pictures/judgehost/cactus_2.png" alt="Test 2 on Cactus"></p>

<p>从上面字节最开始的 patch 的内容来看（因为最近没有足够的精力，我没有去抓现场，因此这一段的内容都是推测），问题应该出在缺页处理（<code class="language-plaintext highlighter-rouge">handle_mm_fault</code>）的时候需要更新内存 cgroup 的统计数据（可以看我<a href="https://blog.taoky.moe/2023-01-01/shattered-notes-max-ram-usage.html#%E5%B0%8F%E6%8F%92%E6%9B%B2cgroup-%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%9F%E8%AE%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84">在一月份的 post</a>，恰巧提到了这个事情），而更新数据需要 <code class="language-plaintext highlighter-rouge">shrink_slab</code>，从而需要 <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code> 的读锁导致的。所以可能只能靠大版本更新内核来缓解问题（或者想办法把上面的 commit backport 到老的内核上）。</p>

<p>这里感谢坏人 (<a href="https://github.com/shankerwangmiao" class="user-mention">@shankerwangmiao</a>) 对此的提问与建议。</p>

<h2 id="结论">结论</h2>

<blockquote>
  <p>Q: Do you judgehosts scale?</p>

  <p>A: With <code class="language-plaintext highlighter-rouge">cgroup_mutex</code> and <code class="language-plaintext highlighter-rouge">shrinker_rwsem</code>, NO (in Linux &lt; 6.3).</p>
</blockquote>

  </div>

  
    <div class="post-comments" itemprop="comment">
      <hr>
<h3>Comments</h3>
<div id="disqus_thread"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqusjs.css">
<link rel="stylesheet" href="/assets/dark-disqus.css">
<script src="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqus.js"></script>
<script>
// https://blog.skk.moe/post/prevent-disqus-from-slowing-your-site/
function loadDisqus() {
    var dsqjs = new DisqusJS({
        shortname: 'taokyblog',
        siteName: 'taoky\'s blog',
        // identifier: '',
        // url: '',
        // title: '',
        api: '//blog.taoky.moe/api/',
        apikey: 'L3W1Q35kDbi2ZGTV2iEfZ8SIksrYf847Ft0ufGon9ye1PTVxG902wO3FtIUq4wgO',
        nocomment: '无评论.',
        admin: 'taoky',
        adminLabel: 'taoky'
    });
}

// 通过检查 window 对象确认是否在浏览器中运行
var runningOnBrowser = typeof window !== "undefined";
// 通过检查 scroll 事件 API 和 User-Agent 来匹配爬虫
var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
// 检查当前浏览器是否支持 IntersectionObserver API
var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;

// 一个小 hack，将耗时任务包裹在 setTimeout(() => { }, 1) 中，可以推迟到 Event Loop 的任务队列中、等待主调用栈清空后才执行，在绝大部分浏览器中都有效
// 其实这个 hack 本来是用于优化骨架屏显示的。一些浏览器总是等 JavaScript 执行完了才开始页面渲染，导致骨架屏起不到降低 FCP 的优化效果，所以通过 hack 将耗时函数放到骨架屏渲染完成后再进行。
setTimeout(function () {
  if (!isBot && supportsIntersectionObserver) {
    // 当前环境不是爬虫、并且浏览器兼容 IntersectionObserver API
    var disqus_observer = new IntersectionObserver(function(entries) {
      // 当前视窗中已出现 Disqus 评论框所在位置
      if (entries[0].isIntersecting) {
        // 加载 Disqus
        loadDisqus();
        // 停止当前的 Observer
        disqus_observer.disconnect();
      }
    }, { threshold: [0] });
    // 设置让 Observer 观察 #disqus_thread 元素
    disqus_observer.observe(document.getElementById('disqus_thread'));
  } else {
    // 当前环境是爬虫、或当前浏览器其不兼容 IntersectionObserver API
    // 直接加载 Disqus
    loadDisqus();
  }
}, 1);

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
// (function() { // DON'T EDIT BELOW THIS LINE
// var d = document, s = d.createElement('script');
// s.src = 'https://taokyblog.disqus.com/embed.js';
// s.setAttribute('data-timestamp', +new Date());
// (d.head || d.body).appendChild(s);
// })();
</script>
<noscript>Disqus comment requires JavaScript.</noscript>
    </div>
  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Author: taoky - Subscribe via <a href="https://blog.taoky.moe/feed.xml">RSS</a>
<br>
License: <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议（CC-BY-NC-SA 4.0）</a>
    </p>

  </div>

</footer>


  </body>

</html>
