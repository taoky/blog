<!DOCTYPE html>
<html lang="zh">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>A Naive Rust Tutorial</title>
  <meta name="description" content="尽管 Rust 官方有非常详尽的资料，但是在很多人眼里，Rust 仍然是一门非常难以上手的语言。我最开始的时候也看过 The Book（The Rust Programming Language）的前几章，发现自己看不下去之后也把 rustlings 里面的 exercises 全部做了一遍，但是还是感觉难以下咽。">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://blog.taoky.moe/2022-05-04/a-naive-rust-tutorial.html">
  
  
  <link rel="alternate" type="application/rss+xml" title="taoky&#39;s blog" href="https://blog.taoky.moe/feed.xml">

  <link rel="stylesheet" href="/assets/typo.css">
<link rel="stylesheet" href="/assets/fonts.css">

  <link href="/assets/fonts/bitter.css" rel="stylesheet">
  
  
  
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-44647340-1', 'auto');
      ga('send', 'pageview');
    </script>
  


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">taoky's blog</a>

    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger">
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewbox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
          </svg>
        </span>
      </label>
      <div class="trigger">
        
        
        <a class="page-link" href="/about/">About</a>
        
        
        <a class="page-link" href="/archives/">Archives</a>
        
        
        <a class="page-link" href="/projects/">Projects</a>
        
        
        <a class="page-link" href="https://www.taoky.moe/TAsterisk">TA*</a>
        
        
        <a class="page-link" href="https://github.com/taoky">GitHub</a>
        
      </div>
    </nav>

  </div>

</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post typo" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">A Naive Rust Tutorial</h1>
    
    <p class="post-meta"><time datetime="2022-05-04T07:44:00+00:00" itemprop="datePublished">May 4, 2022</time> •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/tech/">tech</a>
      
    
      
    
  


 •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/rust/">rust</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/tutorial/">tutorial</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  
  <div class="user-toc">
    <h3>TOC | 目录</h3>
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">安装与配置</a></li>
<li class="toc-entry toc-h1">
<a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">简单的例子</a>
<ul>
<li class="toc-entry toc-h2">
<a href="#%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C">你好，世界！</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E8%BF%88%E5%87%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5">迈出的第一步</a></li>
<li class="toc-entry toc-h3"><a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">简单的错误处理</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%B8%8E-trait">枚举类型与 trait</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%95%B0%E7%BB%84vector%E6%B4%BE%E7%94%9Fderive%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93">数组、Vector、派生（derive）与结构体</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#ports-%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90">Ports 文件列表解析</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85">使用第三方包</a></li>
<li class="toc-entry toc-h3"><a href="#%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6">遍历文件</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">内置数据结构</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">命令行参数</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#executor">“Executor”</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0">线程实现</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0">异步实现</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%E5%B0%B4%E5%B0%AC%E5%B9%B6%E8%A1%8Cn-%E7%9A%87%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E8%A7%A3">尴尬并行：n 皇后的所有解</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0">单线程实现</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92">消息传递</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">共享变量</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%E5%AE%8F">宏</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8F">第一个宏</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%8A%A0%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83">加法的比较</a></li>
<li class="toc-entry toc-h3"><a href="#ansi-csi-%E5%BA%8F%E5%88%97">ANSI CSI 序列</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">函数的默认值</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%E9%93%BE%E8%A1%A8">链表</a>
<ul>
<li class="toc-entry toc-h3"><a href="#stdcollectionslinkedlist-%E4%B8%8D%E4%B9%9F%E6%8C%BA%E5%A5%BD%E5%90%97">std::collections::LinkedList 不也挺好吗？</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%A4%A7%E9%83%A8%E5%88%86%E9%83%BD%E6%98%AF-safe-%E7%9A%84%E4%BC%AA%E9%93%BE%E8%A1%A8">大部分都是 Safe 的伪链表</a></li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%E7%95%AA%E5%A4%96%E7%AF%87%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84-mutable-singleton">番外篇：单线程下的 mutable singleton</a>
<ul>
<li class="toc-entry toc-h3"><a href="#refcell-%E4%B8%8E-thread_local">RefCell 与 thread_local!</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E5%9D%8F">惰性求值，坏</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA">未定义行为</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%9C%80%E5%90%8E%E7%9A%84%E4%BD%9C%E4%B8%9A">最后的作业</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#%E5%90%8E%E8%AE%B0">后记</a></li>
</ul>
  </div>
  

  <div class="post-content" itemprop="articleBody">
    <p>尽管 Rust 官方有非常详尽的资料，但是在很多人眼里，Rust 仍然是一门非常难以上手的语言。我最开始的时候也看过 The Book（The Rust Programming Language）的前几章，发现自己看不下去之后也把 <a href="https://github.com/rust-lang/rustlings/">rustlings</a> 里面的 exercises 全部做了一遍，但是还是感觉难以下咽。</p>

<p>最后发现，（至少对于我来说）入门一门语言最好的方式是把自己实际的需求用这门语言去试一遍：在写了几个实用的脚本程序，用 Rust 去做了一门课的课程实验之后，我发现使用 Rust <strong>根本没有那么难</strong>。</p>

<p>以下内容可能存在错误，欢迎指正。Rust 使用 2021 稳定版本。本文相关代码位于 <a href="https://github.com/taoky/naive-rust-examples">https://github.com/taoky/naive-rust-examples</a>。</p>

<p>相关文档与工具：</p>

<ul>
  <li>The Book: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>
  <li>Rust by Example: <a href="https://doc.rust-lang.org/stable/rust-by-example/">https://doc.rust-lang.org/stable/rust-by-example/</a>
</li>
  <li>The Rust Standard Library: <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a>
</li>
  <li>（非官方）Rust Cookbook: <a href="https://rust-lang-nursery.github.io/rust-cookbook/intro.html">https://rust-lang-nursery.github.io/rust-cookbook/intro.html</a>
</li>
  <li>The Rustonomicon（黑魔法）: <a href="https://doc.rust-lang.org/stable/nomicon/intro.html">https://doc.rust-lang.org/stable/nomicon/intro.html</a>
</li>
  <li>Rust Playground: <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>
</li>
</ul>

<h1 id="安装与配置">安装与配置</h1>

<p>按照官网教程来就行，如果有网络问题的话去换源。</p>

<p>我用的编辑器是 VS Code，几个重要的配置：</p>

<ul>
  <li>配对的括号显示颜色（<strong>Editor › Bracket Pair Colorization: Enabled</strong> 和 <strong>Editor › Guides: Bracket Pairs</strong> 设置成 active）</li>
  <li>扩展：rust-analyzer（Rust 官方那个不好用）。调试可以使用 CodeLLDB 扩展。</li>
  <li>GitHub Copilot（可选，补全 Rust 代码的质量也还行）</li>
</ul>

<p>JetBrains 的 CLion + Rust 插件据说使用体验很好，但是需要收费（学生可以申请免费的教育版）。</p>

<h1 id="简单的例子">简单的例子</h1>

<h2 id="你好世界">你好，世界！</h2>

<h3 id="迈出的第一步">迈出的第一步</h3>

<p>尽管 <code class="language-plaintext highlighter-rouge">rustc</code> 可以编译单个 rust 代码文件，但是一般来说代码会引入第三方的 crate，所以最好还是创建一个 project：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">cargo new --bin helloworld
</span></code></pre></div></div>

<p>Tip：如果觉得这样很烦，可以安装 <code class="language-plaintext highlighter-rouge">cargo-play</code>，详情参见 https://github.com/fanzeyi/cargo-play。或者用 Rust Playground。</p>

<p>项目中有两个文件（编译前）：</p>

<ul>
  <li>
    <p>Cargo.toml：你的项目的名字、版本、依赖信息。</p>

    <div class="language-toml highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"helloworld"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="c"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

<span class="nn">[dependencies]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>src/main.rs：src 目录放源代码。main.rs 里面的 <code class="language-plaintext highlighter-rouge">fn main()</code> 是程序的入口点。</p>
    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>其中 <code class="language-plaintext highlighter-rouge">println</code> 是一个<strong>宏</strong>（macro），需要加 <code class="language-plaintext highlighter-rouge">!</code> 调用。</p>

<p>但是为什么 <code class="language-plaintext highlighter-rouge">println</code> 是宏？别的语言的输出功能似乎都是函数。一个原因是 Rust 中的<strong>函数不支持可变参数</strong>，而 <code class="language-plaintext highlighter-rouge">println</code> 给用户的是可变参数的接口，这只能用宏来实现。</p>

<p>cargo new 默认创建的就是 Hello world 程序，使用以下命令执行：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">cargo run  #</span><span class="w"> </span>包含调试信息的未优化版本
<span class="gp">cargo run --release  #</span><span class="w"> </span>优化后的版本
</code></pre></div></div>

<p>编译之后会生成 <code class="language-plaintext highlighter-rouge">target</code> 目录（存放编译结果文件）和 <code class="language-plaintext highlighter-rouge">Cargo.lock</code> 文件（锁定依赖的版本）。</p>

<p>但是光是输出 Hello, world 没有意思，我们来加点功能：<strong>多语言支持</strong>，用户输入自己想看到的语言，然后程序输出对应语言版本的 Hello, world。</p>

<p>考虑最简单的实现，运行时程序输出一个菜单，用户输入数字选择语言。首先我们要解决的问题是：怎么得到用户输入？</p>

<p>搜索之后可以发现，我们需要从标准库的 <code class="language-plaintext highlighter-rouge">io::stdin()</code> 按行读取数据到字符串中：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">);</span>
</code></pre></div></div>

<p>这里要注意的是：</p>

<ol>
  <li>
    <p>定义变量的时候，需要用 <code class="language-plaintext highlighter-rouge">mut</code> 表明变量的内容是可变化的。这和 shadowing 不太一样：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>想象变量名是一个<strong>标签</strong>。 <code class="language-plaintext highlighter-rouge">mut</code> 表明标签贴上的东西本身是可变化的；而 shadowing 的操作实际上是把标签从某个东西上撕下来，然后贴到另一个东西上，这不需要「这个东西」本身是可变的。</p>
  </li>
  <li>
    <p>稍微对 Rust 有了解的人可能会迷惑 <code class="language-plaintext highlighter-rouge">String</code> 和 <code class="language-plaintext highlighter-rouge">&amp;str</code> 的区别，如果拿 C++ 做对比，Rust 的 <code class="language-plaintext highlighter-rouge">String</code> 就是 <code class="language-plaintext highlighter-rouge">std::string</code>，而 <code class="language-plaintext highlighter-rouge">&amp;str</code> 就像是 <code class="language-plaintext highlighter-rouge">std::string_view</code>。<code class="language-plaintext highlighter-rouge">str</code> 这个类型本身在实践中是没有意义的。<code class="language-plaintext highlighter-rouge">&amp;str</code> 可以指向内存中任意存在的合法字符串，而 <code class="language-plaintext highlighter-rouge">String</code> 是在堆上分配了一块空间给字符串内容。</p>

    <p>当然，两者是可以相互转换的。<code class="language-plaintext highlighter-rouge">&amp;str</code> 到 <code class="language-plaintext highlighter-rouge">String</code> 可以用 <code class="language-plaintext highlighter-rouge">s.to_string()</code>, <code class="language-plaintext highlighter-rouge">s.to_owned()</code>, <code class="language-plaintext highlighter-rouge">String::from(s)</code> 和 <code class="language-plaintext highlighter-rouge">s.into()</code> 实现，而 <code class="language-plaintext highlighter-rouge">String</code> 到 <code class="language-plaintext highlighter-rouge">&amp;str</code> 可以用 <code class="language-plaintext highlighter-rouge">s.to_str()</code> 或者 <code class="language-plaintext highlighter-rouge">&amp;s</code> 实现。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">&amp;mut</code> 与 borrowing 相关。与其他语言不同的是，引用（Reference）也分为可变引用和不可变引用。函数定义时需要指定参数的类型是否为引用、是什么引用。这里，<code class="language-plaintext highlighter-rouge">input</code> 在调用 <code class="language-plaintext highlighter-rouge">read_line()</code> 之后肯定要用到，并且 <code class="language-plaintext highlighter-rouge">read_line</code> 就是要修改 <code class="language-plaintext highlighter-rouge">input</code> 的内容，所以就要可变引用。这一套机制也是保障 Rust 安全性的关键。</p>

    <p>很多时候函数的参数都是引用，否则用户输入的变量在调用函数之后可能就无法使用了（因为被「移动」到了函数里面）。巧妙的地方是，销毁变量的标准库函数 <code class="language-plaintext highlighter-rouge">std::mem::drop()</code> 就用到了这个特性：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">"rubbish"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="k">drop</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="c">// 之后 s 就不能被使用了。</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>标准库没有提供直接把 stdin 输入类型转换成需要的类型（类似于 <code class="language-plaintext highlighter-rouge">int x; cin &gt;&gt; x;</code>）的接口。一方面这样设计看起来会很奇怪（实现 <code class="language-plaintext highlighter-rouge">Stdin</code> 这个 trait 的结构还需要自己实现一套类型转换），另一方面类型转换本身也可能出错，而 Rust 有更优雅的方式处理错误。</p>
  </li>
</ol>

<p>获得了 <code class="language-plaintext highlighter-rouge">input</code> 之后需要类型转换，这一部分内容可以在 <a href="https://doc.rust-lang.org/rust-by-example/conversion/string.html?highlight=parse#parsing-a-string">Rust by Example 里搜到</a>：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<ol>
  <li>
    <p>你会发现这里的类型标注是必须的——通过这种方式，编译器知道应该用什么类型去调用 <code class="language-plaintext highlighter-rouge">parse()</code>。另一种写法是：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">choice</span> <span class="o">=</span> <span class="n">input</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div>    </div>

    <p>这两种写法都能让编译器推断出需要如何去 parse。<code class="language-plaintext highlighter-rouge">::&lt;i32&gt;</code> 这种写法被称为 “turbofish”（<a href="https://turbo.fish/">https://turbo.fish/</a>），并不是没有人想要简化这个语法，但是<a href="https://github.com/rust-lang/rfcs/pull/2527">相关尝试（RFC）在一小时内即宣告失败</a>。</p>
  </li>
  <li>
    <p>这里 <code class="language-plaintext highlighter-rouge">parse()</code> 的返回值不是 <code class="language-plaintext highlighter-rouge">i32</code>，而是 <code class="language-plaintext highlighter-rouge">Result&lt;i32, ParseIntError&gt;</code>，要从 <code class="language-plaintext highlighter-rouge">Result</code> 里取出 <code class="language-plaintext highlighter-rouge">i32</code> 就必须去做错误处理。</p>

    <p><code class="language-plaintext highlighter-rouge">Result&lt;i32, ParseIntError&gt;</code> 代表里面的内容可能是 <code class="language-plaintext highlighter-rouge">Ok(i32)</code> 或者 <code class="language-plaintext highlighter-rouge">Err(ParseIntError)</code>。Rust 通过这种方式在强迫你去做错误检查，以构建更加稳健的应用。最后的 <code class="language-plaintext highlighter-rouge">unwrap()</code> 会检查 <code class="language-plaintext highlighter-rouge">Result</code> 是 <code class="language-plaintext highlighter-rouge">Ok()</code> 还是 <code class="language-plaintext highlighter-rouge">Err()</code>，如果是 <code class="language-plaintext highlighter-rouge">Err</code> 就让程序崩溃（Panic），否则取出 <code class="language-plaintext highlighter-rouge">Ok</code> 里面的数据。</p>
  </li>
</ol>

<p>最后判断输出的语言：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"你好，世界！"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Unrecogized choice"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后这个程序长这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"0: English"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"1: 中文"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"你好，世界！"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Unrecogized choice"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是运行有 warning，而且会崩溃：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">warning: unused `Result` that must be used
</span><span class="gp"> --&gt;</span><span class="w"> </span>src/main.rs:5:5
<span class="go">  |
</span><span class="gp">5 |     std::io::stdin().read_line(&amp;mut input);</span><span class="w">
</span><span class="go">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
</span><span class="gp">  = note: `#</span><span class="o">[</span>warn<span class="o">(</span>unused_must_use<span class="o">)]</span><span class="sb">`</span> on by default
<span class="go">  = note: this `Result` may be an `Err` variant, which should be handled

warning: `helloworld` (bin "helloworld") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
     Running `target/debug/helloworld`
0: English
1: 中文
0
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', src/main.rs:6:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre></div></div>

<p>崩溃的原因很容易发现：<code class="language-plaintext highlighter-rouge">input</code> 中包含了我们输入的数字和<strong>换行符</strong>，<code class="language-plaintext highlighter-rouge">parse()</code> 不会容忍这样的问题（与 C 的 <code class="language-plaintext highlighter-rouge">atoi()</code> 不同）。把换行符 trim 掉就行：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.trim</span><span class="p">();</span>
</code></pre></div></div>

<p>之后程序可以正常运行，但是 warning 也是不能忽视的。这条 warning 代表 <code class="language-plaintext highlighter-rouge">read_line</code> 返回的 <code class="language-plaintext highlighter-rouge">Result</code> （代表这个函数可能执行出错）没有被检查，加上 <code class="language-plaintext highlighter-rouge">unwrap()</code> 可以暂时解决这个问题：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<p>最后程序可以运行，但是不够优雅：</p>

<ol>
  <li>发生错误的时候能不能有更友好的提示，而不是甩出一坨 panic 错误信息？</li>
  <li>如果要添加（很多）语言的时候怎么办？现在的逻辑似乎不够优雅。</li>
</ol>

<h3 id="简单的错误处理">简单的错误处理</h3>

<p>对于第一个问题，在 <code class="language-plaintext highlighter-rouge">unwrap</code> 的文档（如果在用 VS Code，鼠标移到上面也能看到）中有直接的说明：</p>

<blockquote>
  <p>Because this function may panic, its use is generally discouraged. Instead, prefer to use pattern matching and handle the Err case explicitly, or call [unwrap_or], [unwrap_or_else], or [unwrap_or_default].</p>
</blockquote>

<p>Pattern matching 的一种形式是用 <code class="language-plaintext highlighter-rouge">match</code>，看起来像是 switch-case，但是语法更强大一些：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error reading line: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>  <span class="c">// 这里变量 e 就是 Err() 里面包裹的内容</span>
    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{}</span>  <span class="c">// 不与其他任何规则匹配时执行这一条规则</span>
<span class="p">}</span>
</code></pre></div></div>

<p>（<code class="language-plaintext highlighter-rouge">eprintln!</code> 将错误输出到 stderr）</p>

<p>这种 pattern matching 的形式也被其他语言借鉴，比如说 <a href="https://docs.python.org/3/whatsnew/3.10.html">Python 3.10 的 <code class="language-plaintext highlighter-rouge">match</code></a>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">http_error</span><span class="p">(</span><span class="n">status</span><span class="p">):</span>
    <span class="n">match</span> <span class="n">status</span><span class="p">:</span>
        <span class="n">case</span> <span class="mi">400</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"Bad request"</span>
        <span class="n">case</span> <span class="mi">404</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"Not found"</span>
        <span class="n">case</span> <span class="mi">418</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"I'm a teapot"</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">"Something's wrong with the internet"</span>
</code></pre></div></div>

<p>但是这样还是有点繁琐。使用 <code class="language-plaintext highlighter-rouge">cargo clippy</code> 检查项目风格的时候 clippy 也会跟你抱怨：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo clippy
<span class="go">    Checking helloworld v0.1.0 (/path/to/naive-rust-examples/helloworld)
warning: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`
</span><span class="gp"> --&gt;</span><span class="w"> </span>src/main.rs:5:5
<span class="go">  |
5 | /     match std::io::stdin().read_line(&amp;mut input) {
</span><span class="gp">6 | |         Err(e) =&gt;</span><span class="w"> </span>eprintln!<span class="o">(</span><span class="s2">"Error reading line: {}"</span>, e<span class="o">)</span>,
<span class="gp">7 | |         _ =&gt;</span><span class="w"> </span><span class="o">{}</span>
<span class="go">8 | |     }
  | |_____^ help: try this: `if let Err(e) = std::io::stdin().read_line(&amp;mut input) { eprintln!("Error reading line: {}", e) }`
  |
</span><span class="gp">  = note: `#</span><span class="o">[</span>warn<span class="o">(</span>clippy::single_match<span class="o">)]</span><span class="sb">`</span> on by default
<span class="gp">  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#</span>single_match
<span class="go">
warning: `helloworld` (bin "helloworld") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.80s
</span></code></pre></div></div>

<p>所以更好的方法是用 if-let 语法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"Error reading line: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>文档中还提到的几个 <code class="language-plaintext highlighter-rouge">unwrap</code> 的变形，可以用来在出错时给变量设置一个「默认值」</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c">// 若出错，则返回 0</span>
<span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap_or_else</span><span class="p">(|</span><span class="mi">_</span><span class="p">|</span> <span class="p">{</span><span class="mi">0</span><span class="p">});</span>  <span class="c">// 若出错，则执行参数里的这个函数（闭包/lambda），这里这个闭包接受一个不会用到的值，直接返回 0</span>
<span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">();</span>  <span class="c">// 若出错，返回这个类型的默认值。对于 i32 而言，默认值就是 0</span>
</code></pre></div></div>

<p>或者有的时候，还是希望它能直接 panic，只是你不喜欢默认的错误信息，那就 <code class="language-plaintext highlighter-rouge">expect()</code>：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Error reading line"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="枚举类型与-trait">枚举类型与 trait</h3>

<p>接下来解决第二个问题。Rust 中的枚举类型可以帮到我们：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="n">English</span><span class="p">,</span>
    <span class="n">Chinese</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是最后的 if-else 似乎可以改成更加直观的 pattern matching 了（直接用 <code class="language-plaintext highlighter-rouge">i32</code> 当然也能改，但是看起来会有点奇怪）。直接写的话就像这样子：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">match</span> <span class="n">choice</span> <span class="p">{</span>
    <span class="nn">Language</span><span class="p">::</span><span class="n">English</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">),</span>
    <span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"你好，世界！"</span><span class="p">),</span>
    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Unrecogized choice"</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是别忘了 <code class="language-plaintext highlighter-rouge">choice</code> 是 <code class="language-plaintext highlighter-rouge">i32</code>，而我们的枚举类型是 <code class="language-plaintext highlighter-rouge">Language</code>，两者不匹配。Rust 标准库里目前没有将数字转换成 enum 的方式，要么用第三方的 crate 包，要么用 unsafe 的 <code class="language-plaintext highlighter-rouge">transmute</code> 来「强制类型转换」，要么还是要自己手写整数转换成 enum 的方法。这里选择最后一种方式。</p>

<p>这个逻辑可以这样写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">choice</span> <span class="o">=</span> <span class="k">match</span> <span class="n">choice</span> <span class="p">{</span>
    <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">),</span>
    <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">),</span>
    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">match</span> <span class="n">choice</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">),</span>
    <span class="nf">Some</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"你好，世界！"</span><span class="p">),</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Unrecogized choice"</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里新的 <code class="language-plaintext highlighter-rouge">choice</code> 的类型是 <code class="language-plaintext highlighter-rouge">Option&lt;Language&gt;</code>。 <code class="language-plaintext highlighter-rouge">Option</code> 和 <code class="language-plaintext highlighter-rouge">Result</code> 类似：<code class="language-plaintext highlighter-rouge">Result</code> 表示操作是否成功，而 <code class="language-plaintext highlighter-rouge">Option</code> 表示值是否为空。里面可能是 <code class="language-plaintext highlighter-rouge">Some()</code> 或者 <code class="language-plaintext highlighter-rouge">None</code>。（在 <code class="language-plaintext highlighter-rouge">Language</code> 这个 enum 里面加个 <code class="language-plaintext highlighter-rouge">Others</code> 也可以，就不需要 <code class="language-plaintext highlighter-rouge">Option</code> 了）。</p>

<p>但是是否可以做得更好？比如说，让这个转换变成 <code class="language-plaintext highlighter-rouge">Language</code> 这个 enum 的一个方法？参考 <a href="https://stackoverflow.com/a/57578431">https://stackoverflow.com/a/57578431</a>，我们可以给 <code class="language-plaintext highlighter-rouge">Language</code> 实现 <code class="language-plaintext highlighter-rouge">TryFrom</code> trait，然后 <code class="language-plaintext highlighter-rouge">choice.try_into()</code> 就能进行转换：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">TryFrom</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">value</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">),</span>
            <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">),</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(()),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// ...</span>

<span class="k">match</span> <span class="n">choice</span><span class="nf">.try_into</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">),</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"你好，世界！"</span><span class="p">),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Unrecogized choice"</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p>Rust 中没有面向对象的继承，对应的，类似的功能由 trait 机制实现。Trait 定义了一些需要实现的函数，用户通过 <code class="language-plaintext highlighter-rouge">impl &lt;trait&gt; for &lt;struct&gt;</code> 的语法实现这些功能。可以看一下标准库里 <code class="language-plaintext highlighter-rouge">TryFrom</code> trait 的代码：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Sized</span> <span class="p">{</span>
    <span class="c">/// The type returned in the event of a conversion error.</span>
    <span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"try_from"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.34.0"</span><span class="nd">)]</span>
    <span class="k">type</span> <span class="n">Error</span><span class="p">;</span>

    <span class="c">/// Performs the conversion.</span>
    <span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"try_from"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.34.0"</span><span class="nd">)]</span>
    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>这里 <code class="language-plaintext highlighter-rouge">Err</code> 中包裹的类型是 <code class="language-plaintext highlighter-rouge">()</code>，因为我们不需要里面的内容。对应返回错误的时候的值就是 <code class="language-plaintext highlighter-rouge">Err(())</code>。</li>
  <li>为什么 <code class="language-plaintext highlighter-rouge">try_into</code> 知道我们要从 <code class="language-plaintext highlighter-rouge">i32</code> 转换成 <code class="language-plaintext highlighter-rouge">Result&lt;Language, _&gt;</code>？因为 <code class="language-plaintext highlighter-rouge">choice</code> 是 <code class="language-plaintext highlighter-rouge">i32</code>，<code class="language-plaintext highlighter-rouge">match</code> 里的值类型是 <code class="language-plaintext highlighter-rouge">Result&lt;Language, _&gt;</code>，Rust 可以推断出这些信息。</li>
  <li>既然有 <code class="language-plaintext highlighter-rouge">try_into()</code>，如果转换不会出错的话有没有 <code class="language-plaintext highlighter-rouge">into()</code>？没错，对应的转换 trait 就是 <code class="language-plaintext highlighter-rouge">From</code>。</li>
  <li>
    <p>最后一个问题：为什么给 <code class="language-plaintext highlighter-rouge">Language</code> 实现 <code class="language-plaintext highlighter-rouge">TryFrom&lt;i32&gt;</code> 之后就能在 <code class="language-plaintext highlighter-rouge">i32</code> 身上用 <code class="language-plaintext highlighter-rouge">try_into()</code> 了？参考 [https://doc.rust-lang.org/std/primitive.i32.html#impl-TryInto<u>](https://doc.rust-lang.org/std/primitive.i32.html#impl-TryInto%3CU%3E)，因为 `TryInto` trait 是 `i32` 的 blanket implementation（指适用于所有类型的 trait 实现），它的定义是：</u></p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">TryInto</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">T</span>
<span class="k">where</span>
    <span class="n">U</span><span class="p">:</span> <span class="o">~</span><span class="k">const</span> <span class="n">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div>    </div>

    <p>所以 <code class="language-plaintext highlighter-rouge">Language</code> 实现了 <code class="language-plaintext highlighter-rouge">TryFrom&lt;i32&gt;</code> 之后，U = Language, T = i32，T 的 <code class="language-plaintext highlighter-rouge">TryInto&lt;U&gt;</code> 也就有实现了。</p>
  </li>
</ol>

<p>使用 <code class="language-plaintext highlighter-rouge">TryFrom</code> 的另一个好处是，可以为其他的类型实现转换，比如说字符串：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">TryFrom</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">value</span> <span class="p">{</span>
            <span class="s">"en"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">),</span>
            <span class="s">"zh"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">),</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(()),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在结束本小段之前，一句题外话：<code class="language-plaintext highlighter-rouge">Result</code> 和 <code class="language-plaintext highlighter-rouge">Option</code> 事实上也是枚举类型：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">/// Contains the success value</span>
    <span class="nd">#[lang</span> <span class="nd">=</span> <span class="s">"Ok"</span><span class="nd">]</span>
    <span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span> <span class="n">T</span><span class="p">),</span>

    <span class="c">/// Contains the error value</span>
    <span class="nd">#[lang</span> <span class="nd">=</span> <span class="s">"Err"</span><span class="nd">]</span>
    <span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span>
    <span class="nf">Err</span><span class="p">(</span><span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span> <span class="n">E</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">/// No value</span>
    <span class="nd">#[lang</span> <span class="nd">=</span> <span class="s">"None"</span><span class="nd">]</span>
    <span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="c">/// Some value `T`</span>
    <span class="nd">#[lang</span> <span class="nd">=</span> <span class="s">"Some"</span><span class="nd">]</span>
    <span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span>
    <span class="nf">Some</span><span class="p">(</span><span class="nd">#[stable(feature</span> <span class="nd">=</span> <span class="s">"rust1"</span><span class="nd">,</span> <span class="nd">since</span> <span class="nd">=</span> <span class="s">"1.0.0"</span><span class="nd">)]</span> <span class="n">T</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="数组vector派生derive与结构体">数组、Vector、派生（derive）与结构体</h3>

<p>现在我们的代码长成这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="n">English</span><span class="p">,</span>
    <span class="n">Chinese</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TryFrom</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">value</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">),</span>
            <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">),</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(()),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"0: English"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"1: 中文"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span>
        <span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Error reading line"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.trim</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Not an integer"</span><span class="p">);</span>

    <span class="k">match</span> <span class="n">choice</span><span class="nf">.try_into</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">),</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"你好，世界！"</span><span class="p">),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Unrecogized choice"</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>尽管前面做了很多修改，但是现在如果要添加一门新语言，还要修改四个地方：enum、<code class="language-plaintext highlighter-rouge">TryFrom</code> 实现、<code class="language-plaintext highlighter-rouge">main(</code>) 开头的 <code class="language-plaintext highlighter-rouge">println!</code> 和最后的 match，甚至比原来还要麻烦。考虑添加一个数组 <code class="language-plaintext highlighter-rouge">metadata</code>，每一项中存放某门语言对应的 enum、开头要显示的语言名称，和最后 hello world 的文字。</p>

<p>Rust 中的数组长度固定，最简单的代码不难写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">METADATA</span><span class="p">:</span> <span class="p">[(</span><span class="n">Language</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">);</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">,</span> <span class="s">"English"</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">),</span>
    <span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">,</span> <span class="s">"中文"</span><span class="p">,</span> <span class="s">"你好，世界！"</span><span class="p">)</span>
<span class="p">];</span>
</code></pre></div></div>

<ol>
  <li>常量 <code class="language-plaintext highlighter-rouge">const</code> 变量名需要大写（否则有 warning），并且需要写明类型。</li>
  <li>数组的类型是 <code class="language-plaintext highlighter-rouge">[元素类型; 长度]</code>。这里的元素是一个有三项的 tuple。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">main</code> 中对应的代码就可以改成：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="n">in</span> <span class="n">METADATA</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}: {}"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="na">.1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span>
        <span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Error reading line"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.trim</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Not an integer"</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">choice</span> <span class="o">&lt;</span> <span class="n">METADATA</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">METADATA</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="na">.2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Invalid choice"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p>对于一个可迭代的值，最简单的循环写法是：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">METADATA</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>它等价于：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">METADATA</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// i 类型为 (Language, &amp;str, &amp;str)</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p><code class="language-plaintext highlighter-rouge">METADATA.into_iter()</code> 是一个迭代器（iterator）。而上面代码里的 <code class="language-plaintext highlighter-rouge">iter()</code> 也是迭代器，但是每次返回的类型不同：使 <code class="language-plaintext highlighter-rouge">i</code> 成为一个不可变的引用，<code class="language-plaintext highlighter-rouge">iter_mut()</code> 对应则是可变引用。</p>

    <p>PS: <code class="language-plaintext highlighter-rouge">into_iter()</code> 不一定会转移变量的 ownership。</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">METADATA</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// i 类型为 &amp;(Language, &amp;str, &amp;str)</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">METADATA</span><span class="nf">.iter_mut</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// i 类型为 &amp;mut (Language, &amp;str, &amp;str)</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>这里的 enumerate 同时返回了当前迭代次数（即数组的 index）和数组中对应的值，是 <code class="language-plaintext highlighter-rouge">Iterator</code> 这个 trait 的一个方法。</p>
  </li>
  <li>引用 tuple 中某一项的值的语法是 <code class="language-plaintext highlighter-rouge">tuple.index</code>，如代码中的 <code class="language-plaintext highlighter-rouge">value.1</code>。</li>
  <li>
    <p>可以注意到，数组 index 的类型必须是 <code class="language-plaintext highlighter-rouge">usize</code>。和很多设计正常的语言一样，index 不能是负数。（C/C++ 的 <code class="language-plaintext highlighter-rouge">array[index]</code> 其实是指针 <code class="language-plaintext highlighter-rouge">*(array + index)</code> 的语法糖，所以 <code class="language-plaintext highlighter-rouge">index</code> 可以是负数，甚至可以 <code class="language-plaintext highlighter-rouge">index[array]</code>）</p>

    <p>usize 的大小和机器的位长相关。</p>

    <p>用的时候如果是其他类型，可以进行类型转换：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="n">METADATA</span><span class="p">[</span><span class="n">choice</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果数组的 index 超出范围，会在运行时 panic。Rust 编译器无法检测这样的错误：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c">// if choice &lt; METADATA.len() {</span>
<span class="c">//     println!("{}", METADATA[choice].2);</span>
<span class="c">// } else {</span>
<span class="c">//     println!("Invalid choice");</span>
<span class="c">// }</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">METADATA</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="na">.2</span><span class="p">);</span>
</code></pre></div>    </div>

    <div class="language-console highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling helloworld v0.1.0 (/path/to/naive-rust-examples/helloworld)
    Finished dev [unoptimized + debuginfo] target(s) in 1.39s
     Running `target/debug/helloworld`
0: English
1: 中文
3
thread 'main' panicked at 'index out of bounds: the len is 2 but the index is 3', src/main.rs:39:20
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre></div>    </div>

    <p>（没有 warning 哦！）</p>
  </li>
</ol>

<p>现在还有两个问题：</p>

<ol>
  <li>数组的长度要在定义的时候硬编码（虽然长度不对会编译错误）。</li>
  <li>Tuple 会让人对每一项的内容感到迷惑，之后要改顺序之类的也要改后面一堆代码，换成结构体会不会更好？</li>
</ol>

<p>关于问题一，可以试试把数组换成 vector：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">const</span> <span class="n">METADATA</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Language</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">,</span> <span class="s">"English"</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">),</span>
    <span class="p">(</span><span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">,</span> <span class="s">"中文"</span><span class="p">,</span> <span class="s">"你好，世界！"</span><span class="p">)</span>
<span class="p">];</span>
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling helloworld v0.1.0 (/path/to/naive-rust-examples/helloworld)
error[E0308]: mismatched types
</span><span class="gp"> --&gt;</span><span class="w"> </span>src/main.rs:6:47
<span class="go">  |
</span><span class="gp">6 |   const METADATA: Vec&lt;(Language, &amp;str, &amp;str)&gt;</span><span class="w"> </span><span class="o">=</span> <span class="o">[</span>
<span class="go">  |  _______________________________________________^
7 | |     (Language::English, "English", "Hello, world!"),
8 | |     (Language::Chinese, "中文", "你好，世界！")
</span><span class="gp">9 | | ];</span><span class="w">
</span><span class="go">  | | ^- help: try using a conversion method: `.to_vec()`
  | |_|
  |   expected struct `Vec`, found array of 2 elements
  |
</span><span class="gp">  = note: expected struct `Vec&lt;(Language, &amp;'static str, &amp;'static str)&gt;</span><span class="sb">`</span>
<span class="gp">              found array `[(Language, &amp;str, &amp;str);</span><span class="w"> </span>2]<span class="sb">`</span>
<span class="go">
For more information about this error, try `rustc --explain E0308`.
error: could not compile `helloworld` due to previous error
</span></code></pre></div></div>

<p>行行行，数组和 vector 不是同一个类型，那我加个 <code class="language-plaintext highlighter-rouge">.to_vec()</code> 总行了吧：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling helloworld v0.1.0 (/path/to/naive-rust-examples/helloworld)
error[E0277]: the trait bound `Language: Clone` is not satisfied in `(Language, &amp;str, &amp;str)`
</span><span class="gp"> --&gt;</span><span class="w"> </span>src/main.rs:9:3
<span class="go">  |
</span><span class="gp">9 | ].to_vec();</span><span class="w">
</span><span class="go">  |   ^^^^^^ within `(Language, &amp;str, &amp;str)`, the trait `Clone` is not implemented for `Language`
  |
  = note: required because it appears within the type `(Language, &amp;str, &amp;str)`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `helloworld` due to previous error
</span></code></pre></div></div>

<p>这里的错误代表我们的 <code class="language-plaintext highlighter-rouge">Language</code> 枚举类型没有实现 <code class="language-plaintext highlighter-rouge">Clone</code> 这个 trait。难道需要我们手动实现吗？不需要，只需要用 derive 语法让 rust 给我们一个默认的实现就行：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone)]</span>
<span class="k">enum</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="n">English</span><span class="p">,</span>
    <span class="n">Chinese</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Clone</code> 的意思是这个类型结构允许显式的复制。它或许会需要很高的代价（比如说字符串的 clone，不仅要复制指向内容的指针、字符串长度等结构体本身的结构，还要复制结构体中指针指向的字符串实际内容）。对应 <code class="language-plaintext highlighter-rouge">Copy</code> trait 代表只需要简单 <code class="language-plaintext highlighter-rouge">memcpy</code> 结构体/值本身就行。</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s">"naive!"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.clone</span><span class="p">();</span>  <span class="c">// 显式复制（Clone），之后 x 和 s 就是两个没关系的变量了。</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>          <span class="c">// 「移动」语义，因为 String 不是简单结构，没有 Copy trait，所以 s 就「移动」到了 y，s 之后就无法使用了。</span>
<span class="c">// let z = s;       // 编译错误！</span>
<span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>          <span class="c">// 因为 i32 是简单的类型，实现了 Copy trait，所以此时发生了隐式的复制（Copy），y 和 x 值都是 1</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>          <span class="c">// 可以编译</span>
<span class="k">let</span> <span class="n">zz</span> <span class="o">=</span> <span class="n">x</span><span class="nf">.clone</span><span class="p">();</span> <span class="c">// 当然，实现了 Copy 就必然实现了 Clone</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>另一个很常用的 trait 是 <code class="language-plaintext highlighter-rouge">Debug</code>，启用这个 trait 之后就可以方便输出它的值。</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone,</span> <span class="nd">Debug)]</span>
<span class="k">enum</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="n">English</span><span class="p">,</span>
    <span class="n">Chinese</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">;</span>
    <span class="c">// println!("{}", x);  // 编译错误！</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>执行后输出 <code class="language-plaintext highlighter-rouge">English</code>。</p>
  </li>
</ol>

<p>但是很遗憾，<code class="language-plaintext highlighter-rouge">const</code> 中不能出现这样的函数：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling helloworld v0.1.0 (/path/to/naive-rust-examples/helloworld)
error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants
</span><span class="gp">  --&gt;</span><span class="w"> </span>src/main.rs:7:47
<span class="go">   |
</span><span class="gp">7  |   const METADATA: Vec&lt;(Language, &amp;str, &amp;str)&gt;</span><span class="w"> </span><span class="o">=</span> <span class="o">[</span>
<span class="go">   |  _______________________________________________^
8  | |     (Language::English, "English", "Hello, world!"),
9  | |     (Language::Chinese, "中文", "你好，世界！")
</span><span class="gp">10 | | ].to_vec();</span><span class="w">
</span><span class="go">   | |__________^

For more information about this error, try `rustc --explain E0015`.
error: could not compile `helloworld` due to previous error
</span></code></pre></div></div>

<p>尽管这个问题可以被一些方法绕过（比如说使用 <code class="language-plaintext highlighter-rouge">lazy_static</code> 这个第三方 crate），但是对于 const 来说，可能还是数组更好一些。</p>

<p>关于问题二，让我们定义一个结构体：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">LangMeta</span> <span class="p">{</span>
    <span class="n">lang</span><span class="p">:</span> <span class="n">Language</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">greeting</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后 <code class="language-plaintext highlighter-rouge">METADATA</code> 就可以这么定义：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">const</span> <span class="n">METADATA</span><span class="p">:</span> <span class="p">[</span><span class="n">LangMeta</span><span class="p">;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">LangMeta</span> <span class="p">{</span>
        <span class="n">lang</span><span class="p">:</span> <span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"English"</span><span class="p">,</span>
        <span class="n">greeting</span><span class="p">:</span> <span class="s">"Hello, world!"</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">LangMeta</span> <span class="p">{</span>
        <span class="n">lang</span><span class="p">:</span> <span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"中文"</span><span class="p">,</span>
        <span class="n">greeting</span><span class="p">:</span> <span class="s">"你好，世界！"</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">];</span>
</code></pre></div></div>

<p>这里会发现字符串需要从 <code class="language-plaintext highlighter-rouge">&amp;str</code> 转换成 <code class="language-plaintext highlighter-rouge">String</code>。可以字符串后面都加上 <code class="language-plaintext highlighter-rouge">.to_string()</code>，但是为什么不能直接改结构体定义呢？因为已知数据在运行时都不会变化，<code class="language-plaintext highlighter-rouge">&amp;str</code> 似乎可行：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">struct</span> <span class="n">LangMeta</span> <span class="p">{</span>
    <span class="n">lang</span><span class="p">:</span> <span class="n">Language</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">greeting</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是编译器会要求加上 lifetime parameter，因为这些字符串的所有者不是 <code class="language-plaintext highlighter-rouge">LangMeta</code>，它不知道这里引用的字符串值是否会突然消失（别忘了，这里我们没有引用计数 &amp; GC！）</p>

<p>最简单的方法是直接告诉它，这个字符串在整个程序运行的周期里都有效，对应的 lifetime 参数是 <code class="language-plaintext highlighter-rouge">static</code>：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">LangMeta</span> <span class="p">{</span>
    <span class="n">lang</span><span class="p">:</span> <span class="n">Language</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">greeting</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后的代码类似于这样，甚至可以再加几门语言：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Clone,</span> <span class="nd">Debug)]</span>
<span class="k">enum</span> <span class="n">Language</span> <span class="p">{</span>
    <span class="n">English</span><span class="p">,</span>
    <span class="n">Chinese</span><span class="p">,</span>
    <span class="n">Japanese</span><span class="p">,</span>
    <span class="n">Esperanto</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">LangMeta</span> <span class="p">{</span>
    <span class="c">// enum 没有用到，但是还是留着</span>
    <span class="c">// 使用以下的语法可以 suppress warning</span>
    <span class="nd">#[allow(dead_code)]</span>
    <span class="n">lang</span><span class="p">:</span> <span class="n">Language</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">greeting</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">METADATA</span><span class="p">:</span> <span class="p">[</span><span class="n">LangMeta</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">LangMeta</span> <span class="p">{</span>
        <span class="n">lang</span><span class="p">:</span> <span class="nn">Language</span><span class="p">::</span><span class="n">English</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"English"</span><span class="p">,</span>
        <span class="n">greeting</span><span class="p">:</span> <span class="s">"Hello, world!"</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">LangMeta</span> <span class="p">{</span>
        <span class="n">lang</span><span class="p">:</span> <span class="nn">Language</span><span class="p">::</span><span class="n">Chinese</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"中文"</span><span class="p">,</span>
        <span class="n">greeting</span><span class="p">:</span> <span class="s">"你好，世界！"</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">LangMeta</span> <span class="p">{</span>
        <span class="n">lang</span><span class="p">:</span> <span class="nn">Language</span><span class="p">::</span><span class="n">Japanese</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"日本語"</span><span class="p">,</span>
        <span class="n">greeting</span><span class="p">:</span> <span class="s">"こんにちは、世界！"</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">LangMeta</span> <span class="p">{</span>
        <span class="n">lang</span><span class="p">:</span> <span class="nn">Language</span><span class="p">::</span><span class="n">Esperanto</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"Esperanto"</span><span class="p">,</span>
        <span class="n">greeting</span><span class="p">:</span> <span class="s">"Saluton, mondo!"</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">];</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="n">in</span> <span class="n">METADATA</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}: {}"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="py">.name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span>
        <span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Error reading line"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.trim</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">choice</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Not an integer"</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">choice</span> <span class="o">&lt;</span> <span class="n">METADATA</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">METADATA</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="py">.greeting</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Invalid choice"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ports-文件列表解析">Ports 文件列表解析</h2>

<p>今年寒假的时候我和其他同学对 <a href="https://101.lug.ustc.edu.cn">Linux 101</a> 做了比较大幅度的修订，加了不少东西，包括<a href="https://101.lug.ustc.edu.cn/Ch09/#questions">最后一章中的这道题目</a>：</p>

<blockquote>
  <p>Shell 文本处理工具练习 3：文件列表解析</p>

  <p>Ports 是 BSD 系列操作系统管理编译软件的方式。下面我们将介绍 FreeBSD 操作系统中的 ports 目录结构。</p>

  <p>Ports 目录的第一层为不同软件的分类（诸如音频程序、数据库程序会分别放置在 audio 和 databases 目录下），第二层则为各个软件的目录。在绝大多数软件的目录下都有 <code class="language-plaintext highlighter-rouge">distinfo</code> 文件，用于描述其依赖的源代码包文件的名称、大小和 SHA256 校验值信息。</p>

  <p>例如，<code class="language-plaintext highlighter-rouge">gcc10</code> 软件包的 <code class="language-plaintext highlighter-rouge">distinfo</code> 位于 <code class="language-plaintext highlighter-rouge">lang/gcc10/distinfo</code>，内容类似如下：</p>

  <p><code class="language-plaintext highlighter-rouge">TIMESTAMP = 1619249722 SHA256 (gcc-10.3.0.tar.xz) = 64f404c1a650f27fc33da242e1f2df54952e3963a49e06e73f6940f3223ac344 SIZE (gcc-10.3.0.tar.xz) = 76692288</code></p>

  <p>你的任务是：搜索 ports 中的所有 distinfo，提取所有文件名和 SHA256，按照文件名以字典序排序并输出，每行格式要求如下：</p>

  <p><code class="language-plaintext highlighter-rouge">64f404c1a650f27fc33da242e1f2df54952e3963a49e06e73f6940f3223ac344 gcc-10.3.0.tar.xz</code></p>

  <p>现实中的 ports 文件可以从 <a href="https://mirrors.ustc.edu.cn/freebsd-ports/ports.tar.gz">https://mirrors.ustc.edu.cn/freebsd-ports/ports.tar.gz</a> 下载解压得到。</p>

  <p>注意：少量 <code class="language-plaintext highlighter-rouge">distinfo</code> 文件的 SHA256 对应行最后会有多余的空格或制表符，需要妥善处理。</p>
</blockquote>

<p>这个问题实际上是镜像站<a href="https://github.com/ustclug/ustcmirror-images/blob/master/freebsd-ports/sync-ports.sh">同步 FreeBSD ports 的脚本</a>中的一步（包括最后的「注意」，事实上是前几个月我修的<a href="https://github.com/ustclug/ustcmirror-images/commit/547e97dbd983a5628b4ac43f8f7b2bbdea6c6cfc">把同步下来的文件全删了的大 bug</a>）。当然，同步脚本是用 Shell 写的，但是这里我们用 Rust 来做吧。</p>

<h3 id="使用第三方包">使用第三方包</h3>

<p>Rust 的标准库相比于 Python 这种来说，功能少得多——Python 更倾向于 battery-included，而 Rust 更倾向于让第三方 crate 包做专业的事情，包括生成随机数（crate rand，快速生成可靠的随机数不是一件容易事！）、以及正则表达式（crate regex）。</p>

<p>Rust 添加依赖的方式非常简单粗暴，编辑 Cargo.toml，在 <code class="language-plaintext highlighter-rouge">[dependencies]</code> 里加依赖：</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[dependencies]</span>
<span class="py">regex</span> <span class="p">=</span> <span class="s">"1"</span>  <span class="c"># 也可以精确到 1.5.5 这样子</span>
</code></pre></div></div>

<p>之后 build/run 的时候就会下载依赖。</p>

<p>PS: <code class="language-plaintext highlighter-rouge">cargo add</code> 功能今年四月份已经加入 cargo 仓库（<a href="https://github.com/rust-lang/cargo/pull/10472">https://github.com/rust-lang/cargo/pull/10472</a>），可能再过几年，添加依赖就不需要手改 toml 了。</p>

<p>解析文件这个问题我们也考虑用正则表达式解决，所以先把<a href="https://github.com/rust-lang/regex">这个依赖</a>加上。</p>

<h3 id="遍历文件">遍历文件</h3>

<p>ports.tar.gz 解压之后可以得到一个很大的目录树，所以如何遍历文件是一个必须要解决的问题。去搜索的话会找到 <a href="https://rust-lang-nursery.github.io/rust-cookbook/file/dir.html">https://rust-lang-nursery.github.io/rust-cookbook/file/dir.html</a>，可以发现 walkdir 是一个不错的 crate。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">walkdir</span><span class="p">::</span><span class="n">WalkDir</span><span class="p">;</span>

<span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="nn">WalkDir</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">entry</span><span class="o">?</span><span class="nf">.path</span><span class="p">()</span><span class="nf">.display</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>（<a href="https://docs.rs/walkdir/latest/walkdir/">https://docs.rs/walkdir/latest/walkdir/</a>）</p>

<p>于是思路就简单了：对于每个 <code class="language-plaintext highlighter-rouge">entry</code>，判断文件名是不是 <code class="language-plaintext highlighter-rouge">distinfo</code>，如果是，读文件，对第二行正则表达式读取文件名和 SHA256，把结果放进一个 Vec。最后排序输出就行。</p>

<ol>
  <li>
    <p>这里的问号是一个语法糖：代表在返回 <code class="language-plaintext highlighter-rouge">Result</code>/<code class="language-plaintext highlighter-rouge">Option</code> 的函数里，如果前面的值是 <code class="language-plaintext highlighter-rouge">Err</code>/<code class="language-plaintext highlighter-rouge">None</code>，就直接返回。</p>

    <p><code class="language-plaintext highlighter-rouge">main()</code> 默认的返回值是空，但是也可以让它返回 <code class="language-plaintext highlighter-rouge">Result</code>：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="nn">WalkDir</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">entry</span><span class="o">?</span><span class="nf">.path</span><span class="p">()</span><span class="nf">.display</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>其中 <code class="language-plaintext highlighter-rouge">std::error::Error</code> 是一个 trait，trait 本身作为 <code class="language-plaintext highlighter-rouge">Err</code> 中的内容类型没有什么意义，我们希望的是 <code class="language-plaintext highlighter-rouge">Err</code> 中的内容实现这个 trait（这两者是不同的），其对应的类型就是 <code class="language-plaintext highlighter-rouge">Box&lt;dyn Error&gt;</code>。<code class="language-plaintext highlighter-rouge">Box</code> 代表这个指针指向的内容在堆上，因为编译期不知道 Error 对应内容的大小。</p>

    <p><code class="language-plaintext highlighter-rouge">Box&lt;dyn trait&gt;</code> 也可以用来实现「虚函数」的功能，可以作为在运行时才知道是哪个结构体的值的类型。一个实验中遇到的例子是：同时实现了两种 cache 替换算法，用户在运行时指定选择哪种算法，那么算法暴露的接口由一个 trait 实现，而「算法对象」的类型就是 <code class="language-plaintext highlighter-rouge">Box&lt;dyn ReplacementAlgorithm&gt;</code>。</p>

    <p>与之相对应的，<code class="language-plaintext highlighter-rouge">impl trait</code> 可以在编译期已知参数结构体的情况下为结构体生成对应的代码（相比于 <code class="language-plaintext highlighter-rouge">Box&lt;dyn trait&gt;</code>，它在运行时的开销更小，但是生成的程序的体积更大，因为需要为每种结构体都生成函数实现）。</p>

    <p>参考代码<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Madoka</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Homura</span><span class="p">;</span>

<span class="k">trait</span> <span class="n">Magi</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Magi</span> <span class="k">for</span> <span class="n">Madoka</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="s">"Kaname"</span><span class="nf">.to_string</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Magi</span> <span class="k">for</span> <span class="n">Homura</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="s">"Akemi"</span><span class="nf">.to_string</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">showname_static</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">impl</span> <span class="n">Magi</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"(static) {:}"</span><span class="p">,</span> <span class="n">m</span><span class="nf">.name</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">showname_dynamic</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">dyn</span> <span class="n">Magi</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"(dynmaic) {:}"</span><span class="p">,</span> <span class="n">m</span><span class="nf">.name</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span>
        <span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Error reading line"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.trim</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">madoka</span> <span class="o">=</span> <span class="n">Madoka</span> <span class="p">{};</span>
    <span class="k">let</span> <span class="n">homura</span> <span class="o">=</span> <span class="n">Homura</span> <span class="p">{};</span>

    <span class="k">match</span> <span class="n">input</span> <span class="p">{</span>
        <span class="s">"madoka"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">showname_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">madoka</span><span class="p">);</span>
            <span class="nf">showname_dynamic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">madoka</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="s">"homura"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">showname_static</span><span class="p">(</span><span class="o">&amp;</span><span class="n">homura</span><span class="p">);</span>
            <span class="nf">showname_dynamic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">homura</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"unrecognized input"</span><span class="p">),</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>看类型可以知道 <code class="language-plaintext highlighter-rouge">entry?.path()</code> 返回 <code class="language-plaintext highlighter-rouge">std::path::Path</code>，阅读 <a href="https://doc.rust-lang.org/nightly/std/path/struct.Path.html">https://doc.rust-lang.org/nightly/std/path/struct.Path.html</a> 可以得到我们需要的方法。于是可以一下子写出这样的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="nn">WalkDir</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"/tmp/ports"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">entry</span><span class="o">?</span><span class="nf">.path</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">path</span><span class="nf">.file_name</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="s">"distinfo"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>第一个问题是 <code class="language-plaintext highlighter-rouge">path.file_name()</code> 类型是 <code class="language-plaintext highlighter-rouge">Option&lt;&amp;OsStr&gt;</code>，但是我们的 <code class="language-plaintext highlighter-rouge">Some("distinfo")</code> 的类型是 <code class="language-plaintext highlighter-rouge">Option&lt;&amp;'static str&gt;</code>。参考 <a href="https://stackoverflow.com/questions/42101070/how-to-match-a-file-extension-represented-as-an-osstr">https://stackoverflow.com/questions/42101070/how-to-match-a-file-extension-represented-as-an-osstr</a>，由于<a href="https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride">文件名不一定是合法的 UTF-8 字符串</a>，而 Rust 的字符串是 UTF-8，两者不能完全保证对应，所以分成不同的类型是可以理解的。因为我们明确知道 ports 里没有乱七八糟的文件名，所以对应的修改方法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">entry</span><span class="o">?</span><span class="nf">.path</span><span class="p">();</span>
<span class="k">match</span> <span class="n">path</span><span class="nf">.file_name</span><span class="p">()</span><span class="nf">.and_then</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">ffi</span><span class="p">::</span><span class="nn">OsStr</span><span class="p">::</span><span class="n">to_str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="s">"distinfo"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">and_then()</code> 是 <code class="language-plaintext highlighter-rouge">Option</code> 的链式调用的一部分：如果是 <code class="language-plaintext highlighter-rouge">None</code> 就返回 <code class="language-plaintext highlighter-rouge">None</code>，如果是 <code class="language-plaintext highlighter-rouge">Some</code> 就用参数中的函数处理。但是这个代码还是有问题的：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling ports-distinfo-parse v0.1.0 (/path/to/naive-rust-examples/ports-distinfo-parse)
error[E0716]: temporary value dropped while borrowed
</span><span class="gp"> --&gt;</span><span class="w"> </span>src/main.rs:7:20
<span class="go">  |
</span><span class="gp">7 |         let path = entry?.path();</span><span class="w">
</span><span class="go">  |                    ^^^^^^       - temporary value is freed at the end of this statement
  |                    |
  |                    creates a temporary which is freed while still in use
8 |         match path.file_name().and_then(std::ffi::OsStr::to_str) {
  |               ---- borrow later used here
  |
  = note: consider using a `let` binding to create a longer lived value

For more information about this error, try `rustc --explain E0716`.
error: could not compile `ports-distinfo-parse` due to previous error
</span></code></pre></div></div>

<p>这个错误实话讲很反直觉：<code class="language-plaintext highlighter-rouge">entry?</code>（或者 <code class="language-plaintext highlighter-rouge">entry.unwrap()</code>）执行之后的结果是一个「临时变量」，这个临时变量会在这一行结束之后被丢弃，但是 <code class="language-plaintext highlighter-rouge">path</code> 有对这个临时变量内容的引用，所以出错。修这个「问题」很简单：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">entry</span><span class="nf">.path</span><span class="p">();</span>
<span class="k">match</span> <span class="n">path</span><span class="nf">.file_name</span><span class="p">()</span><span class="nf">.and_then</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">ffi</span><span class="p">::</span><span class="nn">OsStr</span><span class="p">::</span><span class="n">to_str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="s">"distinfo"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>之后也可以搜索到打开并读取文件内容的代码（<a href="https://doc.rust-lang.org/rust-by-example/std_misc/file/read_lines.html">https://doc.rust-lang.org/rust-by-example/std_misc/file/read_lines.html</a>）</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
    <span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">,</span>
    <span class="nn">io</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">BufRead</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">use</span> <span class="nn">walkdir</span><span class="p">::</span><span class="n">WalkDir</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="nn">WalkDir</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"/tmp/ports"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">entry</span><span class="nf">.path</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">path</span><span class="nf">.file_name</span><span class="p">()</span><span class="nf">.and_then</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">ffi</span><span class="p">::</span><span class="nn">OsStr</span><span class="p">::</span><span class="n">to_str</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="s">"distinfo"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">lines</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">lines</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">line</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">line</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"SHA256"</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c">// extract filename and sha256</span>
                    <span class="c">// ...</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于 SHA256 不一定在 <code class="language-plaintext highlighter-rouge">distinfo</code> 的第二行（实际写代码测试一下就能发现），所以还是需要遍历每一行。</p>

<h3 id="正则表达式">正则表达式</h3>

<p>正则不难写，最简单的写法是：</p>

<pre><code class="language-regex">SHA256 \((.+)\) = (\w+)
</code></pre>

<p>阅读 <a href="https://docs.rs/regex/latest/regex/">https://docs.rs/regex/latest/regex/</a> 文档，可以知道首先我们需要定义 regex：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">re</span> <span class="o">=</span> <span class="nn">Regex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">r"SHA256 \((.+)\) = (\w+)"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">re</code> 的类型是 <code class="language-plaintext highlighter-rouge">Regex</code>。因此再读 Regex struct 的文档，可以知道要使用 captures（<a href="https://docs.rs/regex/latest/regex/struct.Regex.html#method.captures">https://docs.rs/regex/latest/regex/struct.Regex.html#method.captures</a>），最后的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">caps</span> <span class="o">=</span> <span class="n">re</span><span class="nf">.captures</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">caps</span><span class="nf">.get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_str</span><span class="p">();</span>
<span class="k">let</span> <span class="n">sha256</span> <span class="o">=</span> <span class="n">caps</span><span class="nf">.get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_str</span><span class="p">();</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{} {}"</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sha256</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="内置数据结构">内置数据结构</h3>

<p>Rust 标准库的 <code class="language-plaintext highlighter-rouge">collections</code> 提供了一些常用的数据结构（<a href="https://doc.rust-lang.org/std/collections/index.html">https://doc.rust-lang.org/std/collections/index.html</a>），包括：</p>

<ul>
  <li>Vector、双端队列和链表</li>
  <li>哈希表（Map）和 B 树表</li>
  <li>哈希集合（Set）和 B 树集合</li>
  <li>二叉堆（优先队列）</li>
</ul>

<p>当然，我们这里的需求用 vector 就可以解决。直接改的话会写出这样的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="c">// ...</span>
<span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">lines</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">line</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">line</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"SHA256"</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// extract filename and sha256</span>
            <span class="k">let</span> <span class="n">caps</span> <span class="o">=</span> <span class="n">re</span><span class="nf">.captures</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">caps</span><span class="nf">.get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_str</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">sha256</span> <span class="o">=</span> <span class="n">caps</span><span class="nf">.get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_str</span><span class="p">();</span>
            <span class="n">result</span><span class="nf">.push</span><span class="p">((</span><span class="n">filename</span><span class="p">,</span> <span class="n">sha256</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这是无法通过编译的：因为 <code class="language-plaintext highlighter-rouge">filename</code> 和 <code class="language-plaintext highlighter-rouge">sha256</code> 都是 <code class="language-plaintext highlighter-rouge">&amp;str</code>，但是在循环的过程中上一次的引用的目标会被丢弃。这里我们必须要复制（转换成 <code class="language-plaintext highlighter-rouge">String</code>）：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="nf">.push</span><span class="p">((</span><span class="n">filename</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="n">sha256</span><span class="nf">.to_owned</span><span class="p">()));</span>
</code></pre></div></div>

<p>（<code class="language-plaintext highlighter-rouge">to_string()</code> 也可以，几种转换方式没有区别）</p>

<p>在全部处理完成之后再排序输出：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span><span class="nf">.sort</span><span class="p">();</span>
<span class="k">for</span> <span class="n">item</span> <span class="n">in</span> <span class="n">result</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{} {}"</span><span class="p">,</span> <span class="n">item</span><span class="na">.1</span><span class="p">,</span> <span class="n">item</span><span class="na">.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是 tuple 之间怎么比较呢？文档中没有很清楚的描述，阅读标准库源代码可以发现这个过程是递归的，会从第一个元素开始比较：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">lexical_cmp</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$a:expr</span><span class="p">,</span> <span class="nv">$b:expr</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$rest_a:expr</span><span class="p">,</span> <span class="nv">$rest_b:expr</span><span class="p">),</span><span class="o">+</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Equal</span> <span class="k">=&gt;</span> <span class="nd">lexical_cmp!</span><span class="p">(</span><span class="nv">$</span><span class="p">(</span><span class="nv">$rest_a</span><span class="p">,</span> <span class="nv">$rest_b</span><span class="p">),</span><span class="o">+</span><span class="p">),</span>
            <span class="n">ordering</span>   <span class="k">=&gt;</span> <span class="n">ordering</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$a:expr</span><span class="p">,</span> <span class="nv">$b:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$b</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因为我们第一个元素就是需要排序的文件名，所以直接 <code class="language-plaintext highlighter-rouge">sort()</code> 没有问题。</p>

<p>最后这个能够运行的代码不算长：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
    <span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">,</span>
    <span class="nn">io</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">BufRead</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">use</span> <span class="nn">regex</span><span class="p">::</span><span class="n">Regex</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">walkdir</span><span class="p">::</span><span class="n">WalkDir</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">re</span> <span class="o">=</span> <span class="nn">Regex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">r"SHA256 \((.+)\) = (\w+)"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="nn">WalkDir</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"/tmp/ports"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">entry</span><span class="nf">.path</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">path</span><span class="nf">.file_name</span><span class="p">()</span><span class="nf">.and_then</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">ffi</span><span class="p">::</span><span class="nn">OsStr</span><span class="p">::</span><span class="n">to_str</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="s">"distinfo"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">lines</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">line</span> <span class="n">in</span> <span class="n">lines</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">line</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">line</span><span class="nf">.starts_with</span><span class="p">(</span><span class="s">"SHA256"</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c">// extract filename and sha256</span>
                    <span class="k">let</span> <span class="n">caps</span> <span class="o">=</span> <span class="n">re</span><span class="nf">.captures</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">caps</span><span class="nf">.get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_str</span><span class="p">();</span>
                    <span class="k">let</span> <span class="n">sha256</span> <span class="o">=</span> <span class="n">caps</span><span class="nf">.get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_str</span><span class="p">();</span>
                    <span class="n">result</span><span class="nf">.push</span><span class="p">((</span><span class="n">filename</span><span class="nf">.to_owned</span><span class="p">(),</span> <span class="n">sha256</span><span class="nf">.to_owned</span><span class="p">()));</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">result</span><span class="nf">.sort</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">item</span> <span class="n">in</span> <span class="n">result</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} {}"</span><span class="p">,</span> <span class="n">item</span><span class="na">.1</span><span class="p">,</span> <span class="n">item</span><span class="na">.0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="命令行参数">命令行参数</h3>

<p>现在还有一个问题：<code class="language-plaintext highlighter-rouge">"/tmp/ports"</code> 这个参数如果能从命令行参数输入就好了。从 cookbook 里可以搜到 clap crate 可以解决这个问题。</p>

<p>仿照 clap 的 example 写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Parser,</span> <span class="nd">Debug)]</span>
<span class="nd">#[clap(author,</span> <span class="nd">version,</span> <span class="nd">about,</span> <span class="nd">long_about</span> <span class="nd">=</span> <span class="nd">None)]</span>
<span class="k">struct</span> <span class="n">Args</span> <span class="p">{</span>
    <span class="c">/// Path of ports</span>
    <span class="nd">#[clap(short,</span> <span class="nd">long)]</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="c">// ...</span>
<span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Args</span><span class="p">::</span><span class="nf">parse</span><span class="p">();</span>
<span class="c">// ...</span>
<span class="k">for</span> <span class="n">entry</span> <span class="n">in</span> <span class="nn">WalkDir</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>与此同时我们需要添加依赖，和之前 regex 和 walkdir 不同，为了使用以上的语法，我们需要设定 crate 需要使用的 feature，就像这样子：</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">clap</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"3"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="nn">["derive"]</span> <span class="p">}</span>
</code></pre></div></div>

<p>试运行：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run <span class="nt">--</span> <span class="nt">--help</span>
<span class="go">   Compiling ports-distinfo-parse v0.1.0 (/path/to/naive-rust-examples/ports-distinfo-parse)
    Finished dev [unoptimized + debuginfo] target(s) in 3.07s
     Running `target/debug/ports-distinfo-parse --help`
ports-distinfo-parse 0.1.0

USAGE:
</span><span class="gp">    ports-distinfo-parse --path &lt;PATH&gt;</span><span class="w">
</span><span class="go">
OPTIONS:
    -h, --help           Print help information
</span><span class="gp">    -p, --path &lt;PATH&gt;</span><span class="w">    </span>Path of ports
<span class="go">    -V, --version        Print version information
</span><span class="gp">$</span><span class="w"> </span>cargo run <span class="nt">--</span> <span class="nt">--path</span> /tmp/ports <span class="o">&gt;</span> /tmp/output.txt
</code></pre></div></div>

<p>Done!</p>

<h2 id="executor">“Executor”</h2>

<p>我在大四初学 Go 语言的时候写过一个名叫 executor 的<a href="https://github.com/taoky/executor">小工具</a>：执行程序，接管程序的 stdout 和 stderr，输出的时候前面写上程序的命令和 PID。我很喜欢这个小工具，因为跑实验的时候真的很好用。Go 也是一门不错的语言，<code class="language-plaintext highlighter-rouge">go func</code> 的语法相当方便。</p>

<p>这个例子旨在用 Rust 实现一样的事情（省略掉颜色的实现）。</p>

<h3 id="线程实现">线程实现</h3>

<p>首先要知道怎么启动进程并获取 stdout/stderr。参考 <a href="https://rust-lang-nursery.github.io/rust-cookbook/os/external.html#continuously-process-child-process-outputs">https://rust-lang-nursery.github.io/rust-cookbook/os/external.html#continuously-process-child-process-outputs</a>，用管道连接 stdout 和 stderr，可以写出这样的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
    <span class="nn">process</span><span class="p">::{</span><span class="n">Command</span><span class="p">,</span> <span class="n">Stdio</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">process</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"ls"</span><span class="p">)</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="n">process</span><span class="py">.stdout</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">process</span><span class="py">.stderr</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="c">// ...</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因为我们需要同时处理 stdout 和 stderr，所以一种方法是启动两个线程。Rust 对线程有着很好的支持，the book 中的实际项目例子就是写一个多线程 HTTP 服务器。所以让我们来试一下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">reader</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[stdout] {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="k">let</span> <span class="n">stderr</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stderr</span><span class="p">);</span>
    <span class="n">reader</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[stderr] {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="n">stdout</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="n">stderr</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div>

<p>这里的 <code class="language-plaintext highlighter-rouge">move</code> 代表将闭包内使用的变量「移动」到闭包里面。此时程序已经可以运行了，但是还差一些东西：</p>

<ul>
  <li>
    <p>显示程序名和 PID。</p>

    <p>这个并不难做，但是在 move 的时候会遇到问题：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">program</span> <span class="o">=</span> <span class="s">"ls"</span><span class="p">;</span>
<span class="c">// ...</span>
<span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">process</span><span class="nf">.id</span><span class="p">();</span>
<span class="k">let</span> <span class="n">displayed_name</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"[{}] {}"</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="c">// ...</span>
<span class="c">// 编译不通过！</span>
<span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">reader</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} stdout: {}"</span><span class="p">,</span> <span class="n">displayed_name</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="k">let</span> <span class="n">stderr</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stderr</span><span class="p">);</span>
    <span class="n">reader</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} stderr: {}"</span><span class="p">,</span> <span class="n">displayed_name</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>    </div>

    <p>结果：</p>

    <div class="language-console highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling executor-threaded v0.1.0 (/path/to/naive-rust-examples/executor-threaded)
error[E0382]: use of moved value: `displayed_name`
</span><span class="gp">  --&gt;</span><span class="w"> </span>src/main.rs:24:37
<span class="go">   |
</span><span class="gp">14 |     let displayed_name = format!("[{}] {}", program, pid);</span><span class="w">
</span><span class="go">   |         -------------- move occurs because `displayed_name` has type `String`, which does not implement the `Copy` trait
</span><span class="c">...
</span><span class="go">18 |     let stdout = std::thread::spawn(move || {
   |                                     ------- value moved into closure here
</span><span class="c">...
</span><span class="gp">21 |             println!("{} stdout: {}", displayed_name, line);</span><span class="w">
</span><span class="go">   |                                       -------------- variable moved due to use in closure
</span><span class="c">...
</span><span class="go">24 |     let stderr = std::thread::spawn(move || {
   |                                     ^^^^^^^ value used here after move
</span><span class="c">...
</span><span class="gp">27 |             println!("{} stderr: {}", displayed_name, line);</span><span class="w">
</span><span class="go">   |                                       -------------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `executor-threaded` due to previous error
</span></code></pre></div>    </div>

    <p>这是因为在第一个 move 里面，<code class="language-plaintext highlighter-rouge">displayed_name</code> 已经移入了第一个线程，因此第二个线程无法移入这个变量。
最简单的解决方法是把 <code class="language-plaintext highlighter-rouge">displayed_name</code> 再复制一份，然后为不同的线程提供不同的变量：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">displayed_name</span><span class="nf">.clone</span><span class="p">();</span>
<span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">reader</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} stdout: {}"</span><span class="p">,</span> <span class="n">displayed_name</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="k">let</span> <span class="n">stderr</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stderr</span><span class="p">);</span>
    <span class="n">reader</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} stderr: {}"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>    </div>

    <p>当然也可以用引用计数的智能指针，对应的是 Rust 中的 <code class="language-plaintext highlighter-rouge">Rc</code>，可以让一个变量有多个所有者。在多线程的情况下则需要用原子的 <code class="language-plaintext highlighter-rouge">Arc</code>（A 对应 atomic）：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">displayed_name</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"[{}] {}"</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">pid</span><span class="p">));</span>
<span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">displayed_name</span><span class="p">);</span>
<span class="c">// ... 1st move</span>
<span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">displayed_name</span><span class="p">);</span>
<span class="c">// ... 2nd move</span>
</code></pre></div>    </div>

    <p>当然这里没有这个必要。</p>
  </li>
  <li>
    <p>命令行参数：使用 clap，这里用 clap 的 “Builder API”，不进一步展开 clap 的使用细节。</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">clap</span><span class="p">::{</span><span class="n">Arg</span><span class="p">,</span> <span class="n">Command</span> <span class="k">as</span> <span class="n">ClapCommand</span><span class="p">};</span>

<span class="k">let</span> <span class="n">matches</span> <span class="o">=</span> <span class="nn">ClapCommand</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"executor"</span><span class="p">)</span>
    <span class="nf">.trailing_var_arg</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="nf">.allow_hyphen_values</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="nf">.arg</span><span class="p">(</span>
        <span class="nn">Arg</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"shell"</span><span class="p">)</span>
            <span class="nf">.long</span><span class="p">(</span><span class="s">"shell"</span><span class="p">)</span>
            <span class="nf">.help</span><span class="p">(</span><span class="s">"Use shell to run cmd"</span><span class="p">)</span>
            <span class="nf">.takes_value</span><span class="p">(</span><span class="k">false</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nf">.arg</span><span class="p">(</span><span class="nn">Arg</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cmd"</span><span class="p">)</span><span class="nf">.multiple_values</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="nf">.required</span><span class="p">(</span><span class="k">true</span><span class="p">))</span>
    <span class="nf">.get_matches</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">program</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">matches</span><span class="nf">.values_of</span><span class="p">(</span><span class="s">"cmd"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
<span class="k">let</span> <span class="n">joined</span><span class="p">;</span>
<span class="k">if</span> <span class="n">matches</span><span class="nf">.is_present</span><span class="p">(</span><span class="s">"shell"</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">joined</span> <span class="o">=</span> <span class="n">program</span><span class="nf">.join</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
    <span class="n">program</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"-c"</span><span class="p">,</span> <span class="n">joined</span><span class="nf">.as_str</span><span class="p">()];</span>
<span class="p">}</span>
<span class="k">let</span> <span class="n">process</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">program</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nf">.args</span><span class="p">(</span><span class="o">&amp;</span><span class="n">program</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
    <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
    <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
    <span class="nf">.spawn</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">process</span><span class="nf">.id</span><span class="p">();</span>
<span class="k">let</span> <span class="n">displayed_name</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?} {}"</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>几个点：</p>

    <ol>
      <li>
<code class="language-plaintext highlighter-rouge">collect()</code> 用来将迭代器转换为一个 “collection”（比如说 vector），需要类型标识。</li>
      <li>因为 <code class="language-plaintext highlighter-rouge">sh -c</code> 的第三个参数就是要用 shell 运行的程序，所以需要先 join 用来之后把所有参数塞在 <code class="language-plaintext highlighter-rouge">program[2]</code> 里面。<code class="language-plaintext highlighter-rouge">vec!</code> 是用来快速创建 vector 的宏。</li>
      <li>
<code class="language-plaintext highlighter-rouge">let</code> 可以定义一个未初始化的变量，这里可以让 <code class="language-plaintext highlighter-rouge">joined</code> 不至于在 <code class="language-plaintext highlighter-rouge">if</code> 块结束之后就被销毁，否则 <code class="language-plaintext highlighter-rouge">joined.as_str()</code> 的引用就失效了。</li>
      <li>Rust 用 <code class="language-plaintext highlighter-rouge">x..y</code> 的语法表示 [x, y) 的范围：
        <ol>
          <li>
<code class="language-plaintext highlighter-rouge">1..</code>：从 1 到最后</li>
          <li>
<code class="language-plaintext highlighter-rouge">..5</code>：从 0（最开始）到 5</li>
          <li>
<code class="language-plaintext highlighter-rouge">1..=3</code>：从 1 到 3（包含 3）</li>
        </ol>
      </li>
      <li>
<code class="language-plaintext highlighter-rouge">use</code> 需要用 <code class="language-plaintext highlighter-rouge">Command as ClapCommand</code>，因为和 <code class="language-plaintext highlighter-rouge">std::process</code> 的 <code class="language-plaintext highlighter-rouge">Command</code> 重名了。</li>
    </ol>
  </li>
  <li>
    <p>返回被执行程序的返回值。Rust 的 <code class="language-plaintext highlighter-rouge">main()</code> 不返回退出状态值（internally，调用 <code class="language-plaintext highlighter-rouge">main()</code> 的真正的入口点 <code class="language-plaintext highlighter-rouge">start()</code> 可以返回一个 i32），不过我们可以用 <code class="language-plaintext highlighter-rouge">std::process::exit()</code> 来带返回值退出程序。</p>

    <p>但是还有一个小问题：<code class="language-plaintext highlighter-rouge">process.wait()?</code> 的值是 <code class="language-plaintext highlighter-rouge">ExitStatus</code>，而其 <code class="language-plaintext highlighter-rouge">code()</code> 方法的返回值是 <code class="language-plaintext highlighter-rouge">Option&lt;i32&gt;</code>，当程序被 signal 杀掉的时候值为 <code class="language-plaintext highlighter-rouge">None</code>。迂回的解决方法：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">os</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ExitStatusExt</span><span class="p">;</span>

<span class="c">// 编译不通过！</span>
<span class="k">let</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">process</span><span class="nf">.wait</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">exit</span><span class="p">(</span><span class="k">match</span> <span class="n">return_code</span><span class="nf">.code</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">code</span><span class="p">,</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="mi">128</span> <span class="o">+</span> <span class="n">return_code</span><span class="nf">.signal</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
<span class="p">});</span>
</code></pre></div>    </div>

    <p>可以注意到，<code class="language-plaintext highlighter-rouge">exit()</code> 的返回值是 <code class="language-plaintext highlighter-rouge">!</code>，代表这个函数不会返回。</p>

    <p>但是仍然存在所有权问题：stdout 和 stderr 被移动到了线程里，但是 <code class="language-plaintext highlighter-rouge">process</code> 又要在检查程序返回值的时候用到（而且需要可变引用，而存在一个可变引用的情况下不能有其他任何引用）。Rust 编译器不知道线程是否结束（至少没有把线程是否已经 join 考虑到 borrow checker 里）。标准库文档对此的解决方法是：</p>

    <blockquote>
      <p>The handle for reading from the child’s standard output (stdout), if it has been captured. You might find it helpful to do</p>

      <p><code class="language-plaintext highlighter-rouge">let stdout = child.stdout.take().unwrap();</code></p>

      <p>to avoid partially moving the <code class="language-plaintext highlighter-rouge">child</code> and thus blocking yourself from calling functions on <code class="language-plaintext highlighter-rouge">child</code> while using <code class="language-plaintext highlighter-rouge">stdout</code>.</p>
    </blockquote>

    <p><code class="language-plaintext highlighter-rouge">take()</code> 的作用是把 <code class="language-plaintext highlighter-rouge">Option</code> 里面的值取出来，然后塞个 <code class="language-plaintext highlighter-rouge">None</code> 回去，以此来让 <code class="language-plaintext highlighter-rouge">stdout</code> 和 <code class="language-plaintext highlighter-rouge">stderr</code> 与 <code class="language-plaintext highlighter-rouge">child</code> 脱离关系。</p>

    <p>此外可以注意到，<code class="language-plaintext highlighter-rouge">match</code> 语句在这里是一个完整的表达式，可以直接作为函数的参数，类似的例子诸如替代三元运算符的：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c">// 替代 (y &gt; 1) ? (y * 2) : (y - 5)</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">5</span> <span class="p">};</span>
</code></pre></div>    </div>

    <p>表达式甚至可以是一段完整的程序逻辑：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span> <span class="p">{</span>
        <span class="n">z</span> <span class="o">*</span> <span class="n">y</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>    </div>

    <p>作为程序返回值的语句最后不加分号（所以在函数中的 <code class="language-plaintext highlighter-rouge">return</code> 很多时候是可以省略的）。</p>
  </li>
</ul>

<p>最后的完整代码如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">clap</span><span class="p">::{</span><span class="n">Arg</span><span class="p">,</span> <span class="n">Command</span> <span class="k">as</span> <span class="n">ClapCommand</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">os</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ExitStatusExt</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
    <span class="nn">io</span><span class="p">::{</span><span class="n">BufRead</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">},</span>
    <span class="nn">process</span><span class="p">::{</span><span class="n">exit</span><span class="p">,</span> <span class="n">Command</span><span class="p">,</span> <span class="n">Stdio</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">matches</span> <span class="o">=</span> <span class="nn">ClapCommand</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"executor"</span><span class="p">)</span>
        <span class="nf">.trailing_var_arg</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.allow_hyphen_values</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span>
            <span class="nn">Arg</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"shell"</span><span class="p">)</span>
                <span class="nf">.long</span><span class="p">(</span><span class="s">"shell"</span><span class="p">)</span>
                <span class="nf">.help</span><span class="p">(</span><span class="s">"Use shell to run cmd"</span><span class="p">)</span>
                <span class="nf">.takes_value</span><span class="p">(</span><span class="k">false</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="nn">Arg</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cmd"</span><span class="p">)</span><span class="nf">.multiple_values</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="nf">.required</span><span class="p">(</span><span class="k">true</span><span class="p">))</span>
        <span class="nf">.get_matches</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">program</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">matches</span><span class="nf">.values_of</span><span class="p">(</span><span class="s">"cmd"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">joined</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">matches</span><span class="nf">.is_present</span><span class="p">(</span><span class="s">"shell"</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">joined</span> <span class="o">=</span> <span class="n">program</span><span class="nf">.join</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
        <span class="n">program</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"-c"</span><span class="p">,</span> <span class="n">joined</span><span class="nf">.as_str</span><span class="p">()];</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">process</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">program</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nf">.args</span><span class="p">(</span><span class="o">&amp;</span><span class="n">program</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">process</span><span class="nf">.id</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">displayed_name</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?} {}"</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="n">process</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">process</span><span class="py">.stderr</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="c">// thread for stdout and stderr</span>
    <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">displayed_name</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="n">reader</span>
            <span class="nf">.lines</span><span class="p">()</span>
            <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span>
            <span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{} stdout: {}"</span><span class="p">,</span> <span class="n">displayed_name</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">});</span>
    <span class="k">let</span> <span class="n">stderr</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stderr</span><span class="p">);</span>
        <span class="n">reader</span>
            <span class="nf">.lines</span><span class="p">()</span>
            <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span>
            <span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{} stderr: {}"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">});</span>
    <span class="n">stdout</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">stderr</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">process</span><span class="nf">.wait</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">exit</span><span class="p">(</span><span class="k">match</span> <span class="n">return_code</span><span class="nf">.code</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">code</span><span class="p">,</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="mi">128</span> <span class="o">+</span> <span class="n">return_code</span><span class="nf">.signal</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="异步实现">异步实现</h3>

<p>开启两个线程虽然可以，但是还是「太重」了。如果能用这几年流行的 async 来实现岂不美哉？</p>

<p>对应的：</p>

<ul>
  <li>thread 要变成「协程」；</li>
  <li>协程里面的函数需要是 async 的。</li>
</ul>

<p>两个流行的 async runtime 实现是 tokio 和 async-std。这里选择 async-std，因为它 “provides an async version of std”，对于修改已有代码来说看起来更方便一些。</p>

<p>首先把 <code class="language-plaintext highlighter-rouge">main()</code> 改成 <code class="language-plaintext highlighter-rouge">async</code> 的（需要 attributes feature，<a href="https://docs.rs/async-std/latest/async_std/#examples">https://docs.rs/async-std/latest/async_std/#examples</a>）：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[async_std::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后 <code class="language-plaintext highlighter-rouge">std::thread::spawn</code> 的对应物是 <code class="language-plaintext highlighter-rouge">async_std::task::spawn</code>，所以我们需要：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">async_std</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
    <span class="c">// async func</span>
<span class="p">});</span>
<span class="k">let</span> <span class="n">stderr</span> <span class="o">=</span> <span class="nn">async_std</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
    <span class="c">// async func</span>
<span class="p">});</span>
<span class="n">stdout</span><span class="k">.await</span><span class="p">;</span>
<span class="n">stderr</span><span class="k">.await</span><span class="p">;</span>
</code></pre></div></div>

<p>之后 <code class="language-plaintext highlighter-rouge">BufReader</code> 可以直接使用 <code class="language-plaintext highlighter-rouge">async_std::io::BufReader</code> 替代，但是这需要 <code class="language-plaintext highlighter-rouge">stdout</code> 和 <code class="language-plaintext highlighter-rouge">stderr</code> 是可以异步读取的。因此还需要把 <code class="language-plaintext highlighter-rouge">std::process</code> 的实现换成 <code class="language-plaintext highlighter-rouge">async_std::process</code> 的，这需要 unstable feature（<a href="https://docs.rs/async-std/latest/async_std/process/index.html">https://docs.rs/async-std/latest/async_std/process/index.html</a>），启用之后：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">async_std</span><span class="p">::</span><span class="nn">process</span><span class="p">::{</span><span class="n">exit</span><span class="p">,</span> <span class="n">Command</span><span class="p">,</span> <span class="n">Stdio</span><span class="p">};</span>

<span class="c">// 创建进程的代码不需要更改</span>
<span class="k">let</span> <span class="n">return_code</span> <span class="o">=</span> <span class="n">process</span><span class="nf">.status</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>最后在 async 函数内引入需要的依赖项，最后加上 await（否则返回 future 之后 async 函数就直接结束了）：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">async_std</span><span class="p">::{</span>
    <span class="nn">io</span><span class="p">::{</span><span class="nn">prelude</span><span class="p">::</span><span class="n">BufReadExt</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">},</span>
    <span class="nn">prelude</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">async_std</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="n">reader</span>
        <span class="nf">.lines</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.ok</span><span class="p">())</span>
        <span class="nf">.for_each</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{} stdout: {}"</span><span class="p">,</span> <span class="n">displayed_name</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
        <span class="p">})</span><span class="k">.await</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>搞定。这里给出的仅仅是一个示例，async rust 仍然在快速发展中，希望未来写 async 代码能够和写 sync 代码一样容易。</p>

<h2 id="尴尬并行n-皇后的所有解">尴尬并行：n 皇后的所有解</h2>

<h3 id="单线程实现">单线程实现</h3>

<p>用回溯法解 n 皇后问题需要维护这么几个变量：</p>

<ul>
  <li>每行皇后所处的列数</li>
  <li>每列、两对角线是否存在冲突</li>
</ul>

<p>用 C/C++ 做算法题目的时候可能会把所有这些变量一个一个设置为数组，然后都扔到全局变量里面。但是既然是展示的代码，那么如果可以的话还是要考虑一下代码结构的，比如说把所有状态都放在一个结构体里：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">QueenState</span> <span class="p">{</span>
    <span class="n">board</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">col</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">diag</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>     <span class="c">// x - y</span>
    <span class="n">antidiag</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span> <span class="c">// x + y</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>并且将放置皇后、取消放置和检查的代码放在结构体实现里：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">diag_index</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$row</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$col</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$n</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c">// $row - $col + $n - 1</span>
        <span class="nv">$row</span> <span class="o">+</span> <span class="nv">$n</span> <span class="o">-</span> <span class="nv">$col</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">QueenState</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">QueenState</span> <span class="p">{</span>
            <span class="n">board</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nb">None</span><span class="p">;</span> <span class="n">n</span><span class="p">],</span>
            <span class="n">col</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="n">n</span><span class="p">],</span>
            <span class="n">diag</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">antidiag</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">n</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// fn diag_index(&amp;self, row: usize, col: usize) -&gt; usize {</span>
    <span class="c">//     row - col + self.n - 1</span>
    <span class="c">// }</span>

    <span class="k">fn</span> <span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.board</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="nb">None</span><span class="p">);</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.board</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">col</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.col</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.diag</span><span class="p">[</span><span class="nd">diag_index!</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="k">self</span><span class="py">.n</span><span class="p">)]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.antidiag</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">unput</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.board</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="nf">Some</span><span class="p">(</span><span class="n">col</span><span class="p">));</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.board</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.col</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.diag</span><span class="p">[</span><span class="nd">diag_index!</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="k">self</span><span class="py">.n</span><span class="p">)]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.antidiag</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span><span class="p">);</span>
        <span class="o">!</span><span class="k">self</span><span class="py">.col</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">self</span><span class="py">.diag</span><span class="p">[</span><span class="nd">diag_index!</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="k">self</span><span class="py">.n</span><span class="p">)]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">self</span><span class="py">.antidiag</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里：</p>

<ol>
  <li>需要使用 <code class="language-plaintext highlighter-rouge">self</code> 的方法（instance 的方法）的第一个参数都是 <code class="language-plaintext highlighter-rouge">&amp;self</code> 或者 <code class="language-plaintext highlighter-rouge">&amp;mut self</code>，代表不可变/可变 borrow self。假使类型可以不是引用的话，那 <code class="language-plaintext highlighter-rouge">instance.method()</code> 执行完之后 <code class="language-plaintext highlighter-rouge">instance</code> 就用不了了，这绝大多数时候都不行。</li>
  <li>
<code class="language-plaintext highlighter-rouge">debug_assert</code> 用来在 debug 模式（非 release 模式）下 assert，release 的时候不会执行。</li>
  <li>
    <p>这边定义了宏 <code class="language-plaintext highlighter-rouge">diag_index</code> 用来计算左上到右下对角线是否有重复的数组（<code class="language-plaintext highlighter-rouge">self.diag</code>）的 index。定义成 method 直接使用的话会有 borrow 的问题：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">fn</span> <span class="nf">diag_index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">row</span> <span class="o">-</span> <span class="n">col</span> <span class="o">+</span> <span class="k">self</span><span class="py">.n</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">put</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.board</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">==</span> <span class="nb">None</span><span class="p">);</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.n</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.board</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">col</span><span class="p">);</span>
    <span class="k">self</span><span class="py">.col</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="c">// self.diag[diag_index!(row, col, self.n)] = true;</span>
    <span class="k">self</span><span class="py">.diag</span><span class="p">[</span><span class="k">self</span><span class="nf">.diag_index</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.antidiag</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-console highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling nqueen-channel v0.1.0 (/path/to/naive-rust-examples/nqueen-channel)
error[E0502]: cannot borrow `*self` as immutable because it is also borrowed as mutable
</span><span class="gp">  --&gt;</span><span class="w"> </span>src/main.rs:37:19
<span class="go">   |
</span><span class="gp">37 |         self.diag[self.diag_index(row, col)] = true;</span><span class="w">
</span><span class="go">   |         ----------^^^^----------------------
   |         |         |
   |         |         immutable borrow occurs here
   |         mutable borrow occurs here
   |         mutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `nqueen-channel` due to previous error
</span></code></pre></div>    </div>

    <p>因为 <code class="language-plaintext highlighter-rouge">self.diag</code> 已经 mutable borrow 了 <code class="language-plaintext highlighter-rouge">self</code>，index 里面再 borrow 就不行了。如果分开来写又有点麻烦，还不如用宏：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">diag_index</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$row</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$col</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$n</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c">// $row - $col + $n - 1</span>
        <span class="nv">$row</span> <span class="o">+</span> <span class="nv">$n</span> <span class="o">-</span> <span class="nv">$col</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>与 C 类语言的宏的字符串替换不同，Rust 的宏是直接在语法树上进行修改的，所以相对而言复杂得多，也能像 C++ 的模板一样玩出很多花样。</p>
  </li>
  <li>
    <p>可以注意到本来写的是 <code class="language-plaintext highlighter-rouge">$row - $col + $n - 1</code>，但是最后改成了 <code class="language-plaintext highlighter-rouge">$row + $n - $col - 1</code>。由于很多程序问题都是预期以外的整数溢出导致的，Rust 的应对策略是（<a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md</a>）：</p>

    <ol>
      <li>Debug 模式下检查是否溢出，如果溢出则 panic；</li>
      <li>Release 模式下不检查溢出，以补码（two’s complement）处理。</li>
    </ol>

    <p>这里由于 row 可能小于 col，会溢出，所以先让它加 n 再做减法。</p>
  </li>
</ol>

<p>然后是 DFS 的逻辑：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">queen</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="nn">QueenState</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">QueenState</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"{:?}"</span><span class="p">,</span>
                <span class="n">state</span><span class="py">.board</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.unwrap</span><span class="p">())</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
            <span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">state</span><span class="nf">.check</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">state</span><span class="nf">.put</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
                <span class="nf">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">state</span><span class="nf">.unput</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p>函数里面可以套函数，这里就可以给用户更加简洁的接口。Mutable 的全局变量 <code class="language-plaintext highlighter-rouge">static mut</code> 反而会麻烦很多很多，不仅初始值只能接受 const 的函数，而且所有访问和修改都必须在 <code class="language-plaintext highlighter-rouge">unsafe</code> 里面。</p>

    <p>不过和某些语言（JavaScript）不同，这里内层的函数不是闭包，访问外层函数的变量仍然需要显式传值。</p>
  </li>
  <li>
    <p>最后 <code class="language-plaintext highlighter-rouge">board</code> 里面的类型是 <code class="language-plaintext highlighter-rouge">Option&lt;usize&gt;</code>，所以 <code class="language-plaintext highlighter-rouge">map</code> 来取出 <code class="language-plaintext highlighter-rouge">Some</code> 里面的值（执行到最后理应没有 <code class="language-plaintext highlighter-rouge">None</code>），collect 来重新聚合成 <code class="language-plaintext highlighter-rouge">Vec</code>。<code class="language-plaintext highlighter-rouge">Vec&lt;_&gt;</code> 代表让编译器去推理 <code class="language-plaintext highlighter-rouge">_</code> 的实际类型。</p>
  </li>
</ol>

<p>用户运行的时候直接：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="nf">queen</span><span class="p">(</span><span class="n">SIZE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>就行了。</p>

<p>当然，如果把 8 改成 15，程序运行会慢一些（即使开了 <code class="language-plaintext highlighter-rouge">--release</code>，因为时间复杂度是 <code class="language-plaintext highlighter-rouge">O(n!)</code>）。那么一个自然的想法就是用多线程来计算不同分支的 DFS。</p>

<h3 id="消息传递">消息传递</h3>

<p>Golang 关于并发编程的名句：</p>

<blockquote>
  <p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>

<p>Goroutine 的 channel 用起来也确实方便。而消息传递的模型在 Rust 中也可以轻松使用。这里我们使用消息传递模型让线程把计算结果传递到主线程再输出。</p>

<p>在加入消息传递之前，先修改一下代码，将第一行放置不同列的任务分配到不同的线程：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">queen</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">starting_col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">debug_assert!</span><span class="p">(</span><span class="n">starting_col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">state</span> <span class="o">=</span> <span class="nn">QueenState</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">state</span><span class="nf">.put</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">starting_col</span><span class="p">);</span>
    <span class="c">// ...</span>
    <span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">THREAD</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">THREAD</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">)</span><span class="o">..</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="n">range</span> <span class="p">{</span>
                <span class="nf">queen</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
        <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">handle</span> <span class="n">in</span> <span class="n">handles</span> <span class="p">{</span>
        <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后就是消息传递的改造，使用 <code class="language-plaintext highlighter-rouge">std::sync::mpsc</code>（mpsc: “multi producer, single consumer”，多个生产/发送者 + 一个消费/接收者），创建 channel 的语法如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">channel</span><span class="p">();</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">tx</code> 是给计算线程的发送端（Sender），<code class="language-plaintext highlighter-rouge">rx</code> 是主线程的接收端（Receiver）。但是光加这一行会报错，因为无法推断 <code class="language-plaintext highlighter-rouge">Sender&lt;&gt;</code> 和 <code class="language-plaintext highlighter-rouge">Receiver&lt;&gt;</code> 里面的类型是什么。我们先修改 <code class="language-plaintext highlighter-rouge">queen()</code>，加上 <code class="language-plaintext highlighter-rouge">tx</code> 参数：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">queen</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">starting_col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tx</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
    <span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">QueenState</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">tx</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Sender</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">state</span><span class="py">.board</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.unwrap</span><span class="p">())</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
            <span class="n">tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c">// ...</span>
    <span class="p">}</span>
    <span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Sender</code> 没有实现 <code class="language-plaintext highlighter-rouge">Copy</code> trait，所以 <code class="language-plaintext highlighter-rouge">dfs</code> 的 <code class="language-plaintext highlighter-rouge">tx</code> 参数必须是引用，否则递归的时候 <code class="language-plaintext highlighter-rouge">tx</code> 的 ownership 就被下一层 DFS 吃了。</p>

<p>之后在直觉上可能会这么写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">THREAD</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">)</span><span class="o">..</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="n">range</span> <span class="p">{</span>
            <span class="nf">queen</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这是错误的：<code class="language-plaintext highlighter-rouge">move</code> 导致第一次创建线程的时候 <code class="language-plaintext highlighter-rouge">tx</code> 被移入。我们需要每次 <code class="language-plaintext highlighter-rouge">clone</code> <code class="language-plaintext highlighter-rouge">tx</code>：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">THREAD</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">)</span><span class="o">..</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="n">range</span> <span class="p">{</span>
            <span class="nf">queen</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后在 <code class="language-plaintext highlighter-rouge">rx</code> 这里等待输出。由于 <code class="language-plaintext highlighter-rouge">tx</code> 和线程的生命周期一致，不需要 <code class="language-plaintext highlighter-rouge">join</code> 了：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">received</span> <span class="n">in</span> <span class="n">rx</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">received</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是运行之后发现，程序在输出结束之后并未退出，而是卡死了：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="c">...
</span><span class="go">[1, 6, 4, 7, 0, 3, 5, 2]
[1, 7, 5, 0, 2, 4, 6, 3]
</span></code></pre></div></div>

<p>这是因为发生了死锁：需要注意到，即使在所有计算线程执行完成后，<code class="language-plaintext highlighter-rouge">tx</code> 变量本体并未被释放，因为变量获得的都是 clone 之后的 <code class="language-plaintext highlighter-rouge">tx</code>。最后 <code class="language-plaintext highlighter-rouge">rx</code> 仍然在等待这个 <code class="language-plaintext highlighter-rouge">tx</code> 发送传达不到的消息。</p>

<p>还记得在本文开头一块提到过的 <code class="language-plaintext highlighter-rouge">std::mem::drop</code> 吗？是它上场的时候了：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="k">drop</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
<span class="k">for</span> <span class="n">received</span> <span class="n">in</span> <span class="n">rx</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">received</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后成功运行。这里的例子告诉我们：Rust 的「内存安全」模型<strong>不</strong>解决死锁的问题（即，死锁也是内存安全的）。死锁检测（预防）本身在编译期也是很难实现的。</p>

<h3 id="共享变量">共享变量</h3>

<p>当然，我们也可以用共享变量 + mutex（互斥锁）的做法来处理这个问题。</p>

<p>前面提到过，线程之间可以用 <code class="language-plaintext highlighter-rouge">Arc</code> 来使得一个变量被多个线程拥有。但是由于同时只能存在一个可变引用，我们希望每个线程都要写入这个变量，所以还需要一个「东西」来暴露出不可变的、但是实际值可以变化的引用。对应实际需求，这就是锁。而在 Rust 中这种性质被称为<a href="https://doc.rust-lang.org/reference/interior-mutability.html#interior-mutability">「内部可变性」（Interior Mutability）</a>。标准库中提供了两种锁：</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Mutex</code>。一旦上锁，其他线程需要等待解锁才能访问变量。</li>
  <li>
<code class="language-plaintext highlighter-rouge">RwLock</code>。多个线程可以同时获取读取锁读取变量，想要写入变量的线程需要等待其他线程读取完成后才能获得写入锁。在某个线程拥有写入锁时，其他线程不管需要读还是写都需要等待。（RwLock 很容易死锁，务必小心！）</li>
</ul>

<p>对应我们的需求的则是 <code class="language-plaintext highlighter-rouge">Mutex</code>。我们的变量这么定义：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()));</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">result</code> 的类型是 <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&lt;Vec&lt;Vec&lt;usize&gt;&gt;&gt;&gt;</code>。类似地，在每次循环的时候也要 clone：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">THREAD</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">)</span><span class="o">..</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">SIZE</span> <span class="o">/</span> <span class="n">THREAD</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">result</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="n">range</span> <span class="p">{</span>
            <span class="nf">queen</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">queen</code> 函数也需要修改：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">queen</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">starting_col</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ...</span>
    <span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">QueenState</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">vec</span><span class="nf">.lock</span><span class="p">()</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
                <span class="nf">.push</span><span class="p">(</span><span class="n">state</span><span class="py">.board</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.unwrap</span><span class="p">())</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c">// ...</span>
    <span class="p">}</span>
    <span class="nf">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">state</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里 <code class="language-plaintext highlighter-rouge">vec.lock().unwrap()</code> 可以给 <code class="language-plaintext highlighter-rouge">vec</code> 上锁，并获取到这个 vector。可以注意到这里没有解锁的代码，这是因为 RAII 的思想：在变量离开它的 scope 之后变量代表的资源（这里是 mutex）就自动被释放了，所以不用担心自己忘了 unlock，前面打开文件之后没有（显式）关闭（事实上 Rust 没有提供「关闭文件」的方法）也是因为 RAII，文件自动就关闭了。</p>

<p>最后等待线程执行结束，然后输出：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">handle</span> <span class="n">in</span> <span class="n">handles</span> <span class="p">{</span>
    <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="k">for</span> <span class="n">item</span> <span class="n">in</span> <span class="n">result</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>尽管已经不再需要锁了，但是最后一下访问还是要 lock。最后的循环用了 <code class="language-plaintext highlighter-rouge">iter()</code> 也是这个原因：默认的 <code class="language-plaintext highlighter-rouge">into_iter()</code> 需要把 vector 的 ownership 从 mutex 里面拿出来，而这在需要加锁的环境下显然会有问题。</p>

<p>尽管程序完成了，这一节还有一样东西可以介绍：如果我们需要的不是每种解法，而只是解的数量呢？我们当然可以给 <code class="language-plaintext highlighter-rouge">i32</code> 或者 <code class="language-plaintext highlighter-rouge">usize</code> 套个 mutex，或者让线程每算出一个解就发送一次消息更新计数器，但是有更简单的方法：原子变量。</p>

<p>首先定义原子变量（<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html#">https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html</a>）：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">atomic</span><span class="p">::</span><span class="n">AtomicUsize</span><span class="p">;</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">AtomicUsize</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<p>可以看到不需要 <code class="language-plaintext highlighter-rouge">Mutex</code>，然后看一下更新和读取的逻辑：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">atomic</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">QueenState</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">cnt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">AtomicUsize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
        <span class="n">cnt</span><span class="nf">.fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// ...</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">result</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">));</span>
</code></pre></div></div>

<p>可以看到，首先 <code class="language-plaintext highlighter-rouge">fetch_add</code> 不需要 <code class="language-plaintext highlighter-rouge">&amp;mut self</code>，所以省下了 mutex lock。然后特别的，在使用原子变量的时候，我们需要去思考一件平时不会在意的问题：内存序。Rust 的内存序系统和 C++20 一致。这里内存序都使用了最严格的顺序（序列一致性），但是实际上不需要这么严格。</p>

<p>思考这样一个问题：多个 CPU（或者 CPU 核心）共享内存中的同一个变量，但是如果每次读写都要走一遍内存，那还是太慢了（<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/memory-performance-in-a-nutshell.html">L1 cache 访问需要 1ns，而 DDR 内存访问需要大约 80ns</a>）。因此每个 CPU 都可能会在自己的缓存里保存变量值，这就带来了一致性相关的问题，如此这般，硬件设计中为了性能考虑带来的一致性问题也就导致了内存序问题，并且不同的架构内存序宽松程度是不同的，这也给跨体系结构的应用移植带来了挑战（导致有些体系结构上运行毫无问题的程序，在另一种架构上编译运行可能就会时不时出现并发问题）。</p>

<p>由弱到强，Rust 中提供了这五种内存序：</p>

<ul>
  <li>Relaxed，不管顺序，只保证修改最终可以写回。</li>
  <li>Release，释放/发布变量的写入，其他线程用更强的内存序的时候，可以保证看到之前的所有写入。</li>
  <li>Acquire，「获取」最新的变量，可以看到之前被 Release 或者更强的内存序写入的内容。</li>
  <li>AcqRel，Acquire + Release，用于既有读取、又有写入的操作。</li>
  <li>SeqCst，在 AcqRel 的基础上保证所有线程看到相同的操作顺序。</li>
</ul>

<p>基于以上介绍，程序代码的内存序可以改成：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">atomic</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">QueenState</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">cnt</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">AtomicUsize</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">n</span> <span class="p">{</span>
        <span class="n">cnt</span><span class="nf">.fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">AcqRel</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// ...</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">result</span><span class="nf">.load</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Acquire</span><span class="p">));</span>
</code></pre></div></div>

<h2 id="宏">宏</h2>

<p>宏在前面已经有一点很简略的介绍。在 the book 中是这样介绍的：</p>

<blockquote>
  <p>macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em></p>
</blockquote>

<p>利用宏我们可以实现一些在原本 Rust 语法中比较麻烦的事情，甚至是定义自己的 DSL，像<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=cdab97d0a7f71d9a13568c97ad3faf3a">这个例子</a>（作者未知，如果知道作者是谁的话可以告诉我 😂）里展示的一样，使用效果：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">定义价格规则</span><span class="o">!</span><span class="p">(</span>
    <span class="err">买</span> <span class="mi">0</span> <span class="o">-</span> <span class="mi">5</span> <span class="err">件</span><span class="p">,</span> <span class="err">单价</span> <span class="mf">5.0</span> <span class="err">元</span><span class="p">,</span>
    <span class="err">买</span> <span class="mi">6</span> <span class="o">-</span> <span class="mi">10</span> <span class="err">件</span><span class="p">,</span> <span class="err">单价</span> <span class="mf">4.0</span> <span class="err">元</span><span class="p">,</span>
    <span class="err">买</span> <span class="mi">11</span> <span class="o">-</span> <span class="mi">20</span> <span class="err">件</span><span class="p">,</span> <span class="err">单价</span> <span class="mf">3.0</span> <span class="err">元</span><span class="p">,</span>
    <span class="err">超过</span> <span class="mi">20</span> <span class="err">件统统</span> <span class="mf">2.5</span> <span class="err">元</span>
<span class="p">);</span>
</code></pre></div></div>

<p class="center"><img src="/pictures/rust/macro_intro_background.png" alt='Background of "定义价格规则" macro'></p>

<p class="center"><em>似乎是这个宏的<a href="https://twitter.com/toooooobug/status/1437252082264731649">故事背景</a>（2022/5/17 added）</em></p>

<p>当然，我的水平有限，这里不介绍复杂的例子。</p>

<h3 id="第一个宏">第一个宏</h3>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">diag_index</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$row</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$col</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$n</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nv">$row</span> <span class="o">+</span> <span class="nv">$n</span> <span class="o">-</span> <span class="nv">$col</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个宏接受三个参数（参数开头都必须是 <code class="language-plaintext highlighter-rouge">$</code>），它们类型都是 <code class="language-plaintext highlighter-rouge">expr</code>（表达式）。参数类型还可以是其他的，例如 <code class="language-plaintext highlighter-rouge">ident</code>（标识符）。<a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">https://doc.rust-lang.org/reference/macros-by-example.html#metavariables</a></p>

<p>使用 <code class="language-plaintext highlighter-rouge">macro_rules!</code> 定义的宏全称为「以例子（构造）的宏」（macros by example），另一种构造方式被称为「（基于）过程的宏」（procedural macros），这里不详细介绍，可参考阅读 <a href="https://doc.rust-lang.org/reference/macros.html">https://doc.rust-lang.org/reference/macros.html</a>。</p>

<h3 id="加法的比较">加法的比较</h3>

<p>前面提到，Rust 对整数溢出问题有着自己的处理方式。以整数加法为例，就有 <code class="language-plaintext highlighter-rouge">checked_add</code>, <code class="language-plaintext highlighter-rouge">wrapping_add</code> 和 <code class="language-plaintext highlighter-rouge">saturating_add</code> 这三种方法。如何测试它们在溢出时的情况呢？</p>

<p>当然可以这么写代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">i32</span><span class="p">::</span><span class="n">MAX</span><span class="nf">.checked_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"i32::MAX + 1 by {} returns {:#?}"</span><span class="p">,</span> <span class="s">"checked_add"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">i32</span><span class="p">::</span><span class="n">MAX</span><span class="nf">.wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"i32::MAX + 1 by {} returns {:#?}"</span><span class="p">,</span> <span class="s">"wrapping_add"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">i32</span><span class="p">::</span><span class="n">MAX</span><span class="nf">.saturating_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"i32::MAX + 1 by {} returns {:#?}"</span><span class="p">,</span> <span class="s">"saturating_add"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>但是用宏可以实现得更优雅。下面是宏的实现：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">custom_add</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$y</span><span class="p">:</span> <span class="n">ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nv">$x</span>.<span class="nv">$y</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} + 1 by {} returns {:#?}"</span><span class="p">,</span> <span class="nv">$x</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$y</span><span class="p">),</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">$x</code> 是表达式（对应 <code class="language-plaintext highlighter-rouge">i32::MAX</code>），<code class="language-plaintext highlighter-rouge">$y</code> 是标识符（对应三种不同的方法）。其中一个关键点是 <code class="language-plaintext highlighter-rouge">stringify!</code> 宏可以给出标识符的字符串表示。于是最后调用代码只需要三行：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">custom_add!</span><span class="p">(</span><span class="nn">i32</span><span class="p">::</span><span class="n">MAX</span><span class="p">,</span> <span class="n">checked_add</span><span class="p">);</span>
<span class="nd">custom_add!</span><span class="p">(</span><span class="nn">i32</span><span class="p">::</span><span class="n">MAX</span><span class="p">,</span> <span class="n">wrapping_add</span><span class="p">);</span>
<span class="nd">custom_add!</span><span class="p">(</span><span class="nn">i32</span><span class="p">::</span><span class="n">MAX</span><span class="p">,</span> <span class="n">saturating_add</span><span class="p">);</span>
</code></pre></div></div>

<p>输出：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">2147483647 + 1 by checked_add returns None
2147483647 + 1 by wrapping_add returns -2147483648
2147483647 + 1 by saturating_add returns 2147483647
</span></code></pre></div></div>

<h3 id="ansi-csi-序列">ANSI CSI 序列</h3>

<p>ANSI 转义序列能控制终端实现很多功能。而其中一类是 CSI 序列。</p>

<p>CSI 序列的格式是 <code class="language-plaintext highlighter-rouge">ESC [</code> + 参数字节（parameter bytes）+ 中间字节（intermediate bytes） + 最终字节（a single final byte）。可以实现例如修改文字前景色和背景色的功能。</p>

<p>在 crossterm 和 termion 这两个 crate 里，组装 csi 序列的宏的代码 完 全 一 致：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">csi</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$</span><span class="p">(</span> <span class="nv">$l:expr</span> <span class="p">),</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="nd">concat!</span><span class="p">(</span><span class="s">"</span><span class="se">\x1B</span><span class="s">["</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span> <span class="nv">$l</span> <span class="p">),</span><span class="o">*</span><span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://github.com/crossterm-rs/crossterm/blob/0b4a06a97fd946dbe11d6eaa9b5db0b319bfb555/src/macros.rs#L4">https://github.com/crossterm-rs/crossterm/blob/0b4a06a97fd946dbe11d6eaa9b5db0b319bfb555/src/macros.rs#L4</a></p>

<p><a href="https://github.com/redox-os/termion/blob/8054e082b01c3f45f89f0db96bc374f1e378deb1/src/macros.rs#L2">https://github.com/redox-os/termion/blob/8054e082b01c3f45f89f0db96bc374f1e378deb1/src/macros.rs#L2</a></p>

<p>然后使用方法如下：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// https://github.com/crossterm-rs/crossterm/blob/0b4a06a97fd946dbe11d6eaa9b5db0b319bfb555/src/style.rs#L384</span>
<span class="nd">csi!</span><span class="p">(</span><span class="s">"0m"</span><span class="p">)</span>  <span class="c">// ESC [0m, 恢复正常</span>
<span class="c">// https://github.com/redox-os/termion/blob/8054e082b01c3f45f89f0db96bc374f1e378deb1/src/color.rs#L53</span>
<span class="nd">csi!</span><span class="p">(</span><span class="s">"38;5;"</span><span class="p">,</span> $<span class="n">value</span><span class="p">,</span> <span class="s">"m"</span><span class="p">)</span> <span class="c">// ESC [38;5;$valuem, 设置前景色</span>

<span class="nd">println!</span><span class="p">(</span>
    <span class="s">"{}{}Hello, color!{}"</span><span class="p">,</span>
    <span class="nd">csi!</span><span class="p">(</span><span class="s">"38;5;"</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"m"</span><span class="p">),</span>
    <span class="nd">csi!</span><span class="p">(</span><span class="s">"48;5;"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"m"</span><span class="p">),</span>
    <span class="nd">csi!</span><span class="p">(</span><span class="s">"0m"</span><span class="p">)</span>
<span class="p">);</span>  <span class="c">// 黑色背景，绿色文字的显示效果</span>
</code></pre></div></div>

<p>这里宏的参数列表出现了一个新的语法：<code class="language-plaintext highlighter-rouge">$(...),*</code>。意思是按照括号内的方式匹配零个或多个参数。这里的参数是 <code class="language-plaintext highlighter-rouge">$( $l:expr ),*</code>，在宏里面引用匹配到的参数时的用法也类似，是 <code class="language-plaintext highlighter-rouge">$( $l ),*</code>。（如果把 <code class="language-plaintext highlighter-rouge">*</code> 换成 <code class="language-plaintext highlighter-rouge">+</code>，就是匹配一个到多个参数）</p>

<p>而 <code class="language-plaintext highlighter-rouge">concat</code> 就是把字面量连接起来成为字符串的宏。</p>

<h3 id="函数的默认值">函数的默认值</h3>

<p>在很多语言里，函数都可以有一个「默认参数」：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">k</span>
</code></pre></div></div>

<p>但是 Rust 的函数不支持默认参数，当然可以这么写：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">k</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是用宏可以给用户提供更方便的接口：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">func</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$a</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$b</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">func</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span>
    <span class="p">};</span>
    <span class="p">(</span><span class="nv">$a</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$b</span><span class="p">:</span> <span class="n">expr</span><span class="p">,</span> <span class="nv">$k</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">func</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="nv">$k</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{} {}"</span><span class="p">,</span> <span class="nd">func!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nd">func!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="c">// println!("{} {}", func(1, 2, Some(3)), func(1, 2, None));</span>
</code></pre></div></div>

<p>这里的宏定义可以重载（overload）：在编译的时候，编译器会选择合适的方法来进行代码替换。</p>

<h2 id="链表">链表</h2>

<p>链表是非常常见的数据结构。尽管有人会这么辩解：</p>

<ul>
  <li>链表对 cache 不友好，对内存的随机访问导致局部性很差</li>
  <li>链表占用的空间比数组/vector 更大（要存储 pointer）</li>
  <li>对于很多 workload，把链表换成数组/vector 不会带来明显的性能损失</li>
</ul>

<p>但是无法回避的是，有的时候就是要用链表，而且 Rust 里面写链表很难（尤其是双端队列，需要与 borrow checker 以非常扭曲的方式搏斗），很多时候不得不与 unsafe 做妥协（说到这个，甚至是标准库的 vec 也还是需要 unsafe 去实现）。关于如何写链表，<a href="https://rust-unofficial.github.io/too-many-lists/index.html">Learn Rust With Entirely Too Many Linked Lists</a> 有着很详细的描述，以下仅对「另一种链表实现」做一个简单的介绍（只写单向链表，并且尽量不要把下面的代码直接用在生产环境上）。</p>

<h3 id="stdcollectionslinkedlist-不也挺好吗">
<code class="language-plaintext highlighter-rouge">std::collections::LinkedList</code> 不也挺好吗？</h3>

<p><del>答：接口（<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>）不好用。</del></p>

<ul>
  <li><del>不能在链表中间插入元素。</del></li>
  <li><del>也不能在有链表元素的所有权的时候直接指定删除链表中的该元素。是有个 <code class="language-plaintext highlighter-rouge">remove()</code>，但是它还是 nightly 特性，而且要把整个链表重新遍历一遍。</del></li>
</ul>

<p><del>如果 <code class="language-plaintext highlighter-rouge">LinkedList</code> 不能满足需要，那只能自己重新实现了。</del></p>

<p>^ 我本来是这么认为的，然后写下面的内容写到一半的时候找资料，发现 <code class="language-plaintext highlighter-rouge">LinkedList</code> 有 <code class="language-plaintext highlighter-rouge">CursorMut</code> 可以实现上面提到的事情，所以挺好的，只要你愿意开 nightly 特性（CursorMut 能够随意移动、插入删除）。</p>

<h3 id="大部分都是-safe-的伪链表">大部分都是 Safe 的伪链表</h3>

<p>在一般的印象里，链表的结构应该是这样子的：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C 类伪代码</span>

<span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">llist</span> <span class="p">{</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是如果把内存指针换成数组的 index 会怎么样呢？（我记得我是高中时候在紫书（《算法竞赛入门经典》）第二章开头看到过这种写法的，当时还在想「居然还能这样」）</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C 类伪代码</span>

<span class="k">struct</span> <span class="nc">llist</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以发现，这里就省去了很多 borrowing 的难题（因为没有指来指去的内存指针了！但是后面也带来了新的问题），相应的，我们的代码需要自己保证维护正确的链表状态。</p>

<p>为了简化代码，假设链表的最大长度（capacity）为定值，并且假设用户自己检查链表是否已满。</p>

<p>首先写 <code class="language-plaintext highlighter-rouge">Node</code> 和链表的结构体，以及新建链表、在表头 push/pop 的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">free</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">capacity</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">free</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">capacity</span> <span class="p">{</span>
            <span class="n">free</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">capacity</span> <span class="p">{</span>
            <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="nb">None</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">LinkedList</span> <span class="p">{</span>
            <span class="n">head</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
            <span class="n">len</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">free</span><span class="p">,</span>
            <span class="n">capacity</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.capacity</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="n">next</span><span class="p">:</span> <span class="k">self</span><span class="py">.head</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">free_index</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">free_index</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">free_index</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">original_head</span> <span class="o">=</span> <span class="k">self</span><span class="py">.head</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">original_head</span><span class="p">]</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="n">node</span><span class="py">.next</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.free</span><span class="nf">.push</span><span class="p">(</span><span class="n">original_head</span><span class="p">);</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="py">.value</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
<code class="language-plaintext highlighter-rouge">free</code> 存储「空闲节点」的 index，用来快速找到可用的 index。</li>
  <li>定义的时候使用到了 Rust 的泛型，便于存储不同类型的值。</li>
  <li>
    <p>不用 <code class="language-plaintext highlighter-rouge">vec![None; capacity]</code> 作为 <code class="language-plaintext highlighter-rouge">nodes</code> 的值，是因为 <code class="language-plaintext highlighter-rouge">vec!</code> 要求 <code class="language-plaintext highlighter-rouge">Option&lt;Node&lt;T&gt;&gt;</code> 是可以 clone 的，但是 T 不一定有 <code class="language-plaintext highlighter-rouge">Clone</code> trait。<code class="language-plaintext highlighter-rouge">vec!</code> 的代码：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>
<span class="c">// macros.rs</span>
<span class="nd">macro_rules!</span> <span class="n">vec</span> <span class="p">{</span>
    <span class="c">// ...</span>
    <span class="p">(</span><span class="nv">$elem:expr</span><span class="p">;</span> <span class="nv">$n:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span>
        <span class="nv">$crate</span><span class="p">::</span><span class="mi">__</span><span class="nd">rust_force_expr!</span><span class="p">(</span><span class="nv">$crate</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="nv">$elem</span><span class="p">,</span> <span class="nv">$n</span><span class="p">))</span>
    <span class="p">);</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// vec/mod.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">from_elem</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elem</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="o">&lt;</span><span class="n">T</span> <span class="k">as</span> <span class="n">SpecFromElem</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">from_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">Global</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>这里 <code class="language-plaintext highlighter-rouge">elem</code> 需要实现 <code class="language-plaintext highlighter-rouge">Clone</code> trait。</p>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">pub</code> 代表对应的结构体/方法可以暴露给其他的模块。</li>
</ol>

<p>于是我们可以写这样的测试代码（参考 <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">https://doc.rust-lang.org/book/ch11-01-writing-tests.html</a>）：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">crate</span><span class="p">::</span><span class="n">LinkedList</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">push_and_pop_front</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nn">LinkedList</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
        <span class="n">llist</span><span class="nf">.push_front</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">llist</span><span class="nf">.push_front</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">llist</span><span class="nf">.push_front</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">llist</span><span class="nf">.push_front</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">llist</span><span class="nf">.pop_front</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">llist</span><span class="nf">.pop_front</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">llist</span><span class="nf">.pop_front</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">llist</span><span class="nf">.pop_front</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是光能在开头 push/pop 的链表是远远无法满足我们的欲望的。首先，我们还需要能够迭代链表中的内容——需要实现一个迭代器。</p>

<p>数据结构的迭代器实现思路是（以下介绍 <code class="language-plaintext highlighter-rouge">Iter</code>，<code class="language-plaintext highlighter-rouge">IntoIter</code> 也类似）：</p>

<ul>
  <li>添加结构 <code class="language-plaintext highlighter-rouge">Iter</code>，存储迭代时必要的状态信息，链表结构体的 <code class="language-plaintext highlighter-rouge">iter()</code> 方法返回 <code class="language-plaintext highlighter-rouge">Iter</code> 结构。</li>
  <li>结构 <code class="language-plaintext highlighter-rouge">Iter</code> 实现 trait <code class="language-plaintext highlighter-rouge">Iterator</code>。</li>
</ul>

<p>那么我们首先来实现 <code class="language-plaintext highlighter-rouge">IntoIter</code>。如果去翻 too many linked lists，会发现它是这么实现 <code class="language-plaintext highlighter-rouge">IntoIter</code> 的：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">IntoIter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c">// access fields of a tuple struct numerically</span>
        <span class="k">self</span><span class="na">.0</span><span class="nf">.pop</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>直接 pop？感觉上讲，把所有权让出来就需要把元素从 collection 里面拽出来，但是对着 vec 去 for 循环的时候好像元素还在 vec 里面，所以我们来看一下：</p>

<ol>
  <li>
    <p>vec 的 <code class="language-plaintext highlighter-rouge">IntoIterator</code> 有三种不同的实现：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">IntoIterator</span> <span class="k">for</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span>  <span class="c">// type Item = &amp;'a T</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">IntoIterator</span> <span class="k">for</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span>  <span class="c">// type Item = &amp;'a mut T</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">IntoIterator</span> <span class="k">for</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span>  <span class="c">// type Item = T</span>
</code></pre></div>    </div>

    <p>分别对应以下三种情况：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">vec</span> <span class="p">{</span>
    <span class="c">// x: &amp;T</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">vec</span> <span class="p">{</span>
    <span class="c">// x: &amp;mut T</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="n">vec</span> <span class="p">{</span>
    <span class="c">// x: T</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>对应最后一种实现就是我们之前看到的 <code class="language-plaintext highlighter-rouge">into_iter()</code> 的表现。</p>
  </li>
  <li>
    <p>「那我 for 的时候好像也没啥问题啊？」，但是实际上在循环结束之后，对应的 vec 就不能再使用了：</p>

    <div class="language-rust highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="n">x</span> <span class="p">{</span> <span class="p">}</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div>    </div>

    <div class="language-console highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo build
<span class="go">   Compiling linkedlist-safefake v0.1.0 (/path/to/naive-rust-examples/linkedlist-safefake)
error[E0382]: borrow of moved value: `x`
</span><span class="gp">   --&gt;</span><span class="w"> </span>src/lib.rs:141:26
<span class="go">    |
</span><span class="gp">139 |         let x = vec![1, 2, 3, 4, 5];</span><span class="w">
</span><span class="gp">    |             - move occurs because `x` has type `Vec&lt;i32&gt;</span><span class="sb">`</span>, which does not implement the <span class="sb">`</span>Copy<span class="sb">`</span> trait
<span class="go">140 |         for _ in x { }
    |                  -
    |                  |
    |                  `x` moved due to this implicit call to `.into_iter()`
    |                  help: consider borrowing to avoid moving into the for loop: `&amp;x`
</span><span class="gp">141 |         println!("{:?}", x);</span><span class="w">
</span><span class="go">    |                          ^ value borrowed here after move
    |
note: this function takes ownership of the receiver `self`, which moves `x`
</span></code></pre></div>    </div>
  </li>
</ol>

<p>所以这里的实现没有问题。<code class="language-plaintext highlighter-rouge">IntoIter</code> 也是最容易实现的迭代器，只要不动脑子 pop 就行了：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">llist</span><span class="p">:</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// ignoring std::iter::IntoIterator for simplicity</span>
<span class="nd">#[allow(clippy::should_implement_trait)]</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">IntoIter</span> <span class="p">{</span> <span class="n">llist</span><span class="p">:</span> <span class="k">self</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">IntoIter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.llist</span><span class="nf">.pop_front</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>（emmmm 其实最好能够给 <code class="language-plaintext highlighter-rouge">LinkedList</code> 实现 <code class="language-plaintext highlighter-rouge">std::iter::IntoIterator trait</code>，但是为了简单化考虑就忽略了）</p>

<p>第二个要实现的是 <code class="language-plaintext highlighter-rouge">Iter</code>，成品长这个样子：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Iter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">llist</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">Iter</span> <span class="p">{</span>
            <span class="n">llist</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span>
            <span class="n">next</span><span class="p">:</span> <span class="k">self</span><span class="py">.head</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">Iter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.next</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.llist.nodes</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.next</span> <span class="o">=</span> <span class="n">node</span><span class="py">.next</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="py">.value</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Iter</code> 结构体内存储链表的引用和 next（下一个节点的信息）。这里的 lifetime <code class="language-plaintext highlighter-rouge">'a</code> 是不得不添加的：它确保了 Iter 的生命周期和链表本体是一致的，由于 Iterator 返回的是引用，所以 type <code class="language-plaintext highlighter-rouge">Item</code> 也要加上 lifetime <code class="language-plaintext highlighter-rouge">'a</code>。</p>

<p>在 <code class="language-plaintext highlighter-rouge">next()</code> 中的 <code class="language-plaintext highlighter-rouge">as_ref()</code> 是 <code class="language-plaintext highlighter-rouge">Option</code> 的一个方法：<code class="language-plaintext highlighter-rouge">self.llist.nodes[next]</code> 的类型是 <code class="language-plaintext highlighter-rouge">&amp;Option&lt;Node&lt;T&gt;&gt;</code>，而 <code class="language-plaintext highlighter-rouge">&amp;Option</code> 没法直接 <code class="language-plaintext highlighter-rouge">unwrap()</code>，<code class="language-plaintext highlighter-rouge">as_ref()</code> 的作用就是把 <code class="language-plaintext highlighter-rouge">&amp;Option&lt;T&gt;</code> 弄成 <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code>。</p>

<p>最后一个是 <code class="language-plaintext highlighter-rouge">IterMut</code>。哦，这个我懂，把 <code class="language-plaintext highlighter-rouge">&amp;</code> 全改成 <code class="language-plaintext highlighter-rouge">&amp;mut</code> 就行了嘛：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">IterMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">llist</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">iter_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IterMut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">IterMut</span> <span class="p">{</span>
            <span class="n">llist</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span>
            <span class="n">next</span><span class="p">:</span> <span class="k">self</span><span class="py">.head</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">IterMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.next</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.llist.nodes</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.next</span> <span class="o">=</span> <span class="n">node</span><span class="py">.next</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">node</span><span class="py">.value</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo build
<span class="go">   Compiling linkedlist-safefake v0.1.0 (/Users/tao/Projects/naive-rust-examples/linkedlist-safefake)
error[E0495]: cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements
</span><span class="gp">   --&gt;</span><span class="w"> </span>src/lib.rs:237:28
<span class="go">    |
</span><span class="gp">237 |                 let node = self.llist.nodes[next].as_mut().unwrap();</span><span class="w">
</span><span class="go">    |                            ^^^^^^^^^^^^^^^^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime defined on the method body at 233:13...
</span><span class="gp">   --&gt;</span><span class="w"> </span>src/lib.rs:233:13
<span class="go">    |
</span><span class="gp">233 |     fn next(&amp;mut self) -&gt;</span><span class="w"> </span>Option&lt;Self::Item&gt; <span class="o">{</span>
<span class="go">    |             ^^^^^^^^^
note: ...so that reference does not outlive borrowed content
</span><span class="gp">   --&gt;</span><span class="w"> </span>src/lib.rs:237:28
<span class="go">    |
</span><span class="gp">237 |                 let node = self.llist.nodes[next].as_mut().unwrap();</span><span class="w">
</span><span class="go">    |                            ^^^^^^^^^^^^^^^^
note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 230:6...
</span><span class="gp">   --&gt;</span><span class="w"> </span>src/lib.rs:230:6
<span class="go">    |
</span><span class="gp">230 | impl&lt;'a, T&gt;</span><span class="w"> </span>Iterator <span class="k">for </span>IterMut&lt;<span class="s1">'a, T&gt; {
</span><span class="go">    |      ^^
note: ...so that the types are compatible
</span><span class="gp">   --&gt;</span><span class="w"> </span>src/lib.rs:233:46
<span class="go">    |
</span><span class="gp">233 |       fn next(&amp;mut self) -&gt;</span><span class="w"> </span>Option&lt;Self::Item&gt; <span class="o">{</span>
<span class="go">    |  ______________________________________________^
234 | |         match self.next {
</span><span class="gp">235 | |             None =&gt;</span><span class="w"> </span>None,
<span class="gp">236 | |             Some(next) =&gt;</span><span class="w"> </span><span class="o">{</span>
<span class="go">...   |
241 | |         }
242 | |     }
    | |_____^
    = note: expected `Iterator`
               found `Iterator`

For more information about this error, try `rustc --explain E0495`.
error: could not compile `linkedlist-safefake` due to previous error
</span></code></pre></div></div>

<p>哈？如果看过 <a href="https://rust-unofficial.github.io/too-many-lists/second-iter-mut.html">https://rust-unofficial.github.io/too-many-lists/second-iter-mut.html</a> 的话可能可以大致知道原因。</p>

<p>在 <code class="language-plaintext highlighter-rouge">Iter</code> 的实现中，输入与输出的 lifetime 无关：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">Iter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// 相当于……</span>
    <span class="k">fn</span> <span class="n">next</span><span class="o">&lt;</span><span class="nv">'b</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'b</span> <span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但在 <code class="language-plaintext highlighter-rouge">next()</code> 中，我们返回的是 <code class="language-plaintext highlighter-rouge">'b</code> 的 <code class="language-plaintext highlighter-rouge">self</code> 中项的引用，而 <code class="language-plaintext highlighter-rouge">'b</code> 比 <code class="language-plaintext highlighter-rouge">'a</code> 小，看起来会出问题……但是一个关键点是，不可变引用是可以复制的（有多少不可变引用都没关系），但是可变引用是不能复制的（两个人同时拿着一个变量的可变引用是会出大问题的）。</p>

<p>在 too many linked lists 的例子里，<code class="language-plaintext highlighter-rouge">IterMut</code> 的 <code class="language-plaintext highlighter-rouge">next()</code> 可以安全实现，一个原因是 <code class="language-plaintext highlighter-rouge">IterMut</code> 不需要整个链表对象的可变引用，但是这里不行：borrow checker 处理不了引用数组/vector 中某一项时的情况，会当成引用了整个数组/vector 来处理。于是……我们只能……</p>

<p>UNSAFE!</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">IterMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.next</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c">// let mut node = self.nodes[next].as_mut().unwrap();</span>
                <span class="c">// self.next = node.next;</span>
                <span class="c">// Some(&amp;mut node.value)</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.llist.nodes</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.next</span> <span class="o">=</span> <span class="n">node</span><span class="py">.next</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">value_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">node</span><span class="py">.value</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
                <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">value_ptr</span> <span class="k">as</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>（至少从我看来，这个 <code class="language-plaintext highlighter-rouge">IterMut</code> 每次 <code class="language-plaintext highlighter-rouge">next()</code> 不可能会得到相同的元素，于是不可能出现一个元素同时有两个可变引用，所以这个代码虽然 unsafe，但是是 “sound”（可靠）的）</p>

<p>这里取 <code class="language-plaintext highlighter-rouge">node.value</code> 的可变引用作为可变的裸指针：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">value_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">node</span><span class="py">.value</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
</code></pre></div></div>

<p>取引用的裸指针是安全的。但是解引用裸指针就不安全了：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">value_ptr</span> <span class="k">as</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>解引用 <code class="language-plaintext highlighter-rouge">value_ptr</code> 之后（<code class="language-plaintext highlighter-rouge">*value_ptr</code>）取它的可变引用，然后类型转换为 <code class="language-plaintext highlighter-rouge">&amp;mut T</code>，和返回值一致。</p>

<p>在实现了三种迭代器后，我们可以写代码来测试：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">init_llist</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nn">LinkedList</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">llist</span><span class="nf">.push_front</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">llist</span><span class="nf">.push_front</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">llist</span><span class="nf">.push_front</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="c">// 3 -&gt; 2 -&gt; 1</span>
    <span class="n">llist</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">llist</span><span class="nf">.iter</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">3</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">into_iter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">llist</span><span class="nf">.into_iter</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">iter_mut</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">llist</span><span class="nf">.iter_mut</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">llist</span><span class="nf">.iter_mut</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">4</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">3</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">2</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，我们希望实现的一个特性是在迭代的同时可以自由插入/删除元素。先在 <code class="language-plaintext highlighter-rouge">LinkedList</code> 上准备好相关代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">insert_next_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="k">self</span><span class="py">.len</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.capacity</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">match</span> <span class="n">current</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.head</span><span class="p">,</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="n">next</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">free_index</span> <span class="o">=</span> <span class="k">self</span><span class="py">.free</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">free_index</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">match</span> <span class="n">current</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">free_index</span><span class="p">),</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">free_index</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="py">.len</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">remove_next_at</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">match</span> <span class="n">current</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.head</span><span class="p">,</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="k">match</span> <span class="n">next</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.free</span><span class="nf">.push</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
            <span class="k">match</span> <span class="n">current</span> <span class="p">{</span>
                <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="n">node</span><span class="py">.next</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="n">node</span><span class="py">.next</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">node</span><span class="py">.value</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">current</code> 为 <code class="language-plaintext highlighter-rouge">None</code> 时，认为「当前位置」是一个指向表头的「幽灵元素」。于是 <code class="language-plaintext highlighter-rouge">push_front</code> 和 <code class="language-plaintext highlighter-rouge">pop_front</code> 的实现也可以简化：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">push_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.insert_next_at</span><span class="p">(</span><span class="nb">None</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop_front</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.remove_next_at</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>之后是 API 的设计，直觉上迭代器应该作为参数，但是首先没法把这个功能在 <code class="language-plaintext highlighter-rouge">LinkedList</code> 上实现：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">iter</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">IterMut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">iter</span><span class="py">.current</span><span class="p">;</span>
    <span class="k">self</span><span class="nf">.insert_next_at</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">iter</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">IterMut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="n">iter</span><span class="py">.current</span><span class="p">;</span>
    <span class="k">self</span><span class="nf">.remove_next_at</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">llist</span><span class="nf">.iter_mut</span><span class="p">();</span>
<span class="c">// 编译不通过！</span>
<span class="n">llist</span><span class="nf">.insert_next</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>因为 <code class="language-plaintext highlighter-rouge">llist.iter_mut();</code> 得到的 <code class="language-plaintext highlighter-rouge">IterMut</code> 中有对 <code class="language-plaintext highlighter-rouge">llist</code> 的可变引用，但是调用 <code class="language-plaintext highlighter-rouge">llist.insert_next</code> 又需要一个对它的可变引用，这是违反规则的。</p>

<p>那既然 <code class="language-plaintext highlighter-rouge">IterMut</code> 迭代器本体有可变引用，那么这个方法放在迭代器上行不行呢？可以是可以，但是得到的玩意儿用起来会很违背直觉。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">IterMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert_next_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">self</span><span class="py">.next</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.llist</span><span class="nf">.insert_next_at</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove_next_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">self</span><span class="py">.next</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.llist</span><span class="nf">.remove_next_at</span><span class="p">(</span><span class="n">next</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">llist</span><span class="nf">.iter_mut</span><span class="p">();</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">3</span><span class="p">));</span>
<span class="c">// OK，我想在 3 后面插入一个 10</span>
<span class="n">iter</span><span class="nf">.insert_next_next</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="c">// ??????</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">2</span><span class="p">));</span>
<span class="c">// ????????????</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iter</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">10</span><span class="p">));</span>
</code></pre></div></div>

<p>当然，理论上讲迭代器里面可以多放点东西，比如多维护一个「当前节点」的信息，但是写起来感觉会很难受。既然 std 里的 linked list 有个 cursor，我们也来实现一个差不多的东西如何？（部分参考了 <a href="https://rust-unofficial.github.io/too-many-lists/sixth-cursors-impl.html">https://rust-unofficial.github.io/too-many-lists/sixth-cursors-impl.html</a>）</p>

<p>首先是结构体定义，以及「向前移动」「看看当前值」和「看看下一个值」：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">CursorMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">llist</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">current</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">CursorMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">move_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.current</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.current</span> <span class="o">=</span> <span class="k">self</span><span class="py">.llist.head</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="k">self</span><span class="py">.llist.nodes</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">self</span><span class="py">.current</span> <span class="o">=</span> <span class="n">node</span><span class="py">.next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">current</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.current</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.llist.nodes</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.value</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">peek_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.current</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.llist.head</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.llist.nodes</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.next</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">match</span> <span class="n">next</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.llist.nodes</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.value</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>简单到难以置信：不需要 unsafe，不需要生命周期。设计上假设它是循环的：如果到链表最后一个元素，<code class="language-plaintext highlighter-rouge">move_next</code> 会把 <code class="language-plaintext highlighter-rouge">current</code> 设置为 <code class="language-plaintext highlighter-rouge">None</code>，再 <code class="language-plaintext highlighter-rouge">move_next</code> 就到了表头。</p>

<p>有人会吐槽：<code class="language-plaintext highlighter-rouge">current</code> 会返回可变引用，那么能不能搞出指向相同元素的多个可变引用呢？</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">llist</span><span class="nf">.cursor_mut</span><span class="p">();</span>
<span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="n">cursor</span><span class="nf">.current</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="n">cursor</span><span class="nf">.current</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="o">*</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">*</span><span class="n">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>答案是不会，因为 <code class="language-plaintext highlighter-rouge">current()</code> 需要 <code class="language-plaintext highlighter-rouge">&amp;mut self</code>，于是 <code class="language-plaintext highlighter-rouge">let mut y</code> 那里就会编译出错。</p>

<p>接口用起来像这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">cursor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">llist</span><span class="py">.cursor_</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.current</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.peek_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">3</span><span class="p">));</span>
    <span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.current</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">3</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.peek_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">2</span><span class="p">));</span>
    <span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.current</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">2</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.peek_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.current</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">1</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.peek_next</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.current</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.peek_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>加个 <code class="language-plaintext highlighter-rouge">insert_next</code> 和 <code class="language-plaintext highlighter-rouge">remove_next</code> 也是小菜一碟：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">insert_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.llist</span><span class="nf">.insert_next_at</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove_next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span> <span class="k">self</span><span class="py">.current</span><span class="p">;</span>
    <span class="k">self</span><span class="py">.llist</span><span class="nf">.remove_next_at</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接口使用体验如下，比迭代器要舒服一些：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">cursor_insert_remove</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">llist</span> <span class="o">=</span> <span class="nf">init_llist</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">llist</span><span class="nf">.cursor_mut</span><span class="p">();</span>
    <span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span>
    <span class="n">cursor</span><span class="nf">.insert_next</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c">// 3 -&gt; 4 -&gt; 2 -&gt; 1</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.peek_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">4</span><span class="p">));</span>
    <span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.current</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="mi">4</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.remove_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.remove_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.remove_next</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="n">cursor</span><span class="nf">.move_next</span><span class="p">();</span> <span class="c">// "ghost start point"</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.remove_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.remove_next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">cursor</span><span class="nf">.remove_next</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">llist</span><span class="py">.len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="番外篇单线程下的-mutable-singleton">番外篇：单线程下的 mutable singleton</h2>

<p>因为我没去跑过 profiling，<strong>以下故事纯属虚构。</strong></p>

<p>前面提到，随机数生成器需要用外部的 crate 实现，比如说 rand。</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 用起来大概像这个样子</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nn">rand</span><span class="p">::</span><span class="nf">thread_rng</span><span class="p">();</span>
<span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="nb">f64</span> <span class="o">=</span> <span class="n">rng</span><span class="nf">.gen</span><span class="p">();</span>
</code></pre></div></div>

<p>但是我（为了写算法课概率算法的作业）出现了一个扭曲的需求：我有一些算法函数，它们的参数和返回值需要完全一致，但是有些函数是确定性算法，不需要 rng，有些函数是概率算法，需要 rng：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// O(n), deterministic algorithm</span>
<span class="k">fn</span> <span class="nf">alg_a</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">StaticLinkedList</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// O(n), probabilistic algorithm</span>
<span class="k">fn</span> <span class="nf">alg_d</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">StaticLinkedList</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// O(sqrt(n)), deterministic algorithm</span>
<span class="k">fn</span> <span class="nf">alg_b</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">StaticLinkedList</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="c">// O(sqrt(n)), probabilistic algorithm</span>
<span class="k">fn</span> <span class="nf">alg_c</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">StaticLinkedList</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>并且我需要为每个函数测运行时间，而且每个函数运行时间都很短，最后的测时不得不精确到 ns。（胡扯中，因为我完全没跑 profiling，丢人）每次初始化 <code class="language-plaintext highlighter-rouge">rand::thread_rng()</code> 恐怕都得 “seeded by the system”，从 ring3 到 ring0 至少得转几个回合吧，那岂不是劣势很大，生成随机数又要 <code class="language-plaintext highlighter-rouge">&amp;mut self</code>，要能有一个全局的随机数生成器就好了。</p>

<p>本节部分参考了 <a href="https://matklad.github.io/2020/10/03/fast-thread-locals-in-rust.html">https://matklad.github.io/2020/10/03/fast-thread-locals-in-rust.html</a>。</p>

<p>以下示例结构体实现如下（简化问题，这个当然不是随机数生成器）：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Singleton</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="nb">u64</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Singleton</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Singleton</span> <span class="p">{</span>
            <span class="n">state</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.state</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.state</span> <span class="o">*</span> <span class="k">self</span><span class="py">.state</span><span class="p">)</span> <span class="o">^</span> <span class="k">self</span><span class="py">.state</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.state</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="refcell-与-thread_local">
<code class="language-plaintext highlighter-rouge">RefCell</code> 与 <code class="language-plaintext highlighter-rouge">thread_local!</code>
</h3>

<p>前面也提到，<code class="language-plaintext highlighter-rouge">static mut</code> 是 unsafe 的，那么就像 <code class="language-plaintext highlighter-rouge">Mutex</code> 有「内部可变性」一样，有没有什么给单线程环境使用的有「内部可变性」的结构呢？答案是 <code class="language-plaintext highlighter-rouge">RefCell</code>。</p>

<p>让我们先来试试：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[macro_use]</span>
<span class="k">extern</span> <span class="n">crate</span> <span class="n">lazy_static</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">mutable_singleton</span><span class="p">::</span><span class="n">Singleton</span><span class="p">;</span>

<span class="nd">lazy_static!</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">ref</span> <span class="n">SINGLETON</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Singleton</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>结果不行：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run
<span class="go">   Compiling mutable-singleton v0.1.0 (/path/to/naive-rust-examples/mutable-singleton)
</span><span class="gp">error[E0277]: `RefCell&lt;Singleton&gt;</span><span class="sb">`</span> cannot be shared between threads safely
<span class="gp">  --&gt;</span><span class="w"> </span>src/bin/thread_local_refcell.rs:7:1
<span class="go">   |
7  | / lazy_static! {
</span><span class="gp">8  | |     static ref SINGLETON: RefCell&lt;Singleton&gt;</span><span class="w"> </span><span class="o">=</span> RefCell::new<span class="o">(</span>Singleton::new<span class="o">(</span>2<span class="o">))</span><span class="p">;</span>
<span class="go">9  | | }
</span><span class="gp">   | |_^ `RefCell&lt;Singleton&gt;</span><span class="sb">`</span> cannot be shared between threads safely
<span class="go">   |
</span><span class="gp">   = help: the trait `Sync` is not implemented for `RefCell&lt;Singleton&gt;</span><span class="sb">`</span>
<span class="go">note: required by a bound in `lazy_static::lazy::Lazy`
</span><span class="gp">  --&gt;</span><span class="w"> </span>/path/to/.cargo/registry/src/&lt;redacted&gt;/lazy_static-1.4.0/src/inline_lazy.rs:19:20
<span class="go">   |
</span><span class="gp">19 | pub struct Lazy&lt;T: Sync&gt;</span><span class="o">(</span>Cell&lt;Option&lt;T&gt;&gt;, Once<span class="o">)</span><span class="p">;</span>
<span class="go">   |                    ^^^^ required by this bound in `lazy_static::lazy::Lazy`
   = note: this error originates in the macro `__lazy_static_create` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0277`.
error: could not compile `mutable-singleton` due to previous error
</span></code></pre></div></div>

<p>必须要 <code class="language-plaintext highlighter-rouge">Sync</code>，但是为此改成 <code class="language-plaintext highlighter-rouge">Mutex</code> 也太荒谬了一些。不过我们有一个线程自己的空间：TLS（Thread Local Storage）。对应可以用 <code class="language-plaintext highlighter-rouge">thread_local!</code> 初始化：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">thread_local!</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">SINGLETON</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Singleton</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了调用 TLS 里面的变量，需要用这样的语法：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SINGLETON</span><span class="nf">.with</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="n">s</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.get</span><span class="p">())</span>
</code></pre></div></div>

<p>加上测时功能，最后我们非常 safe 的代码长这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">,</span> <span class="nn">time</span><span class="p">::</span><span class="n">Instant</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">mutable_singleton</span><span class="p">::</span><span class="n">Singleton</span><span class="p">;</span>

<span class="nd">thread_local!</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">SINGLETON</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Singleton</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="c">// 不要做 inline，因为我们需要测试 get_singleton() 函数本身的性能</span>
<span class="nd">#[inline(never)]</span>
<span class="k">fn</span> <span class="nf">get_singleton</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="n">SINGLETON</span><span class="nf">.with</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="n">s</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.get</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">STEPS</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">before</span> <span class="o">=</span> <span class="nn">Instant</span><span class="p">::</span><span class="nf">now</span><span class="p">();</span>
    <span class="k">for</span> <span class="mi">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">STEPS</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nf">get_singleton</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Time: {} ms"</span><span class="p">,</span> <span class="n">before</span><span class="nf">.elapsed</span><span class="p">()</span><span class="nf">.as_millis</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>执行结果：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run <span class="nt">--release</span> <span class="nt">--bin</span> thread_local_refcell
<span class="go">   Compiling mutable-singleton v0.1.0 (/Users/tao/Projects/naive-rust-examples/mutable-singleton)
    Finished release [optimized] target(s) in 1.17s
     Running `target/release/thread_local_refcell`
14292512616797437954
Time: 4625 ms
</span></code></pre></div></div>

<p>实话讲，好像有点儿慢。</p>

<h3 id="惰性求值坏">惰性求值，坏</h3>

<p>能不能更快一点呢？我们可以把代码往 compiler explorer 里丢过去看看生成出来的汇编长啥样子（<a href="https://godbolt.org/z/6f6YWMbbM">https://godbolt.org/z/6f6YWMbbM</a>）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>example::get_singleton:
        push    rax
        lea     rdi, [rip + example::SINGLETON::__getit::__KEY@TLSLD]
        call    __tls_get_addr@PLT
        cmp     qword ptr [rax + example::SINGLETON::__getit::__KEY@DTPOFF], 0
        je      .LBB5_2
        lea     rax, [rax + example::SINGLETON::__getit::__KEY@DTPOFF+8]
        jmp     .LBB5_3
.LBB5_2:
        call    std::thread::local::fast::Key&lt;T&gt;::try_initialize
        test    rax, rax
        je      .LBB5_5
.LBB5_3:
        cmp     qword ptr [rax], 0
        jne     .LBB5_4
        mov     rdx, qword ptr [rax + 8]
        mov     rcx, rdx
        imul    rcx, rdx
        xor     rcx, rdx
        mov     qword ptr [rax + 8], rcx
        mov     qword ptr [rax], 0
        mov     rax, rcx
        pop     rcx
        ret
.LBB5_4:
        lea     rdi, [rip + .L__unnamed_1]
        lea     rcx, [rip + .L__unnamed_2]
        lea     r8, [rip + .L__unnamed_3]
        mov     rdx, rsp
        mov     esi, 16
        call    qword ptr [rip + core::result::unwrap_failed@GOTPCREL]
        ud2
.LBB5_5:
        lea     rdi, [rip + .L__unnamed_4]
        lea     rcx, [rip + .L__unnamed_5]
        lea     r8, [rip + .L__unnamed_6]
        mov     rdx, rsp
        mov     esi, 70
        call    qword ptr [rip + core::result::unwrap_failed@GOTPCREL]
        ud2
</code></pre></div></div>

<p>啊，可以看到绝大部分……都不是计算代码。每次访问 TLS 里面的值，都要 <code class="language-plaintext highlighter-rouge">std::thread::local::fast::Key&lt;T&gt;::try_initialize</code> 一遍，之后 <code class="language-plaintext highlighter-rouge">RefCell</code> 看起来也要检查一遍是否有多个可变引用。</p>

<p>每次访问都要尝试初始化，是因为 <code class="language-plaintext highlighter-rouge">thread_local!</code> 是惰性求值的，并且由于访问 TLS 的部分套在函数里面，即使有优化也不太容易做。换成 <code class="language-plaintext highlighter-rouge">lazy_static!</code> 也不会有什么成效（而且我测试过会更慢）。</p>

<p>不过好消息是 <code class="language-plaintext highlighter-rouge">RefCell::new</code> 是 <code class="language-plaintext highlighter-rouge">const fn</code>，所以我们可以换成 <code class="language-plaintext highlighter-rouge">static mut</code>：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">mut</span> <span class="n">SINGLETON</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Singleton</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Singleton</span><span class="p">{</span> <span class="n">state</span><span class="p">:</span> <span class="mi">2</span> <span class="p">});</span>
</code></pre></div></div>

<p>（需要把 <code class="language-plaintext highlighter-rouge">state</code> 暴露为 <code class="language-plaintext highlighter-rouge">pub</code>）</p>

<p>然后读值的函数可以改成这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">get_singleton</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">SINGLETON</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.get</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再跑个分看看：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run <span class="nt">--release</span> <span class="nt">--bin</span> unsafe_refcell
<span class="go">    Finished release [optimized] target(s) in 0.01s
     Running `target/release/unsafe_refcell`
14292512616797437954
Time: 3492 ms
</span></code></pre></div></div>

<p>成效很大。</p>

<p>如果现在去看 compiler explorer 的汇编，可以发现优化后的 <code class="language-plaintext highlighter-rouge">get_singleton</code> 已经没有 <code class="language-plaintext highlighter-rouge">RefCell</code> 的检测代码了，但是 compiler explorer 的环境还是稍微有点不同（作为 library 编译而不是作为 binary 编译），所以有必要看看本地的汇编长啥样。</p>

<p>参考 <a href="https://stackoverflow.com/questions/39219961/how-to-get-assembly-output-from-building-with-cargo">https://stackoverflow.com/questions/39219961/how-to-get-assembly-output-from-building-with-cargo</a></p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo rustc <span class="nt">--release</span> <span class="nt">--bin</span> unsafe_refcell <span class="nt">--</span> <span class="nt">--emit</span> asm
<span class="go">   Compiling mutable-singleton v0.1.0 (/path/to/naive-rust-examples/mutable-singleton)
    Finished release [optimized] target(s) in 1.48s
</span></code></pre></div></div>

<p>然后一看汇编，诶？</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__ZN14unsafe_refcell13get_singleton17h6eb17ac91dc81eeaE:
Lfunc_begin0:
	.cfi_startproc
	.cfi_personality 155, _rust_eh_personality
	.cfi_lsda 16, Lexception0
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	pushq	%rbx
	pushq	%rax
	.cfi_offset %rbx, -24
	cmpq	$0, __ZN14unsafe_refcell9SINGLETON17h88c5dcf868329760E(%rip)
	jne	LBB6_3
	movq	$-1, __ZN14unsafe_refcell9SINGLETON17h88c5dcf868329760E(%rip)
Ltmp0:
	leaq	__ZN14unsafe_refcell9SINGLETON17h88c5dcf868329760E+8(%rip), %rdi
	callq	__ZN17mutable_singleton9Singleton3get17h6fcf1a0fa3cd6caeE
Ltmp1:
	incq	__ZN14unsafe_refcell9SINGLETON17h88c5dcf868329760E(%rip)
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq
LBB6_3:
	leaq	L___unnamed_2(%rip), %rdi
	leaq	l___unnamed_3(%rip), %rcx
	leaq	l___unnamed_4(%rip), %r8
	leaq	-16(%rbp), %rdx
	movl	$16, %esi
	callq	__ZN4core6result13unwrap_failed17hefa96ebaf26de4baE
LBB6_4:
Ltmp2:
	movq	%rax, %rbx
	leaq	__ZN14unsafe_refcell9SINGLETON17h88c5dcf868329760E(%rip), %rdi
	callq	__ZN4core3ptr75drop_in_place$LT$core..cell..RefMut$LT$mutable_singleton..Singleton$GT$$GT$17h34cad5c1b5c9ff9dE
	movq	%rbx, %rdi
	callq	__Unwind_Resume
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">RefCell</code> 的逻辑分明还在呢。说明时间还有缩短的空间。</p>

<p>因为已经是 <code class="language-plaintext highlighter-rouge">static mut</code> 了，去掉 <code class="language-plaintext highlighter-rouge">RefCell</code> 很简单：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">mut</span> <span class="n">SINGLETON</span><span class="p">:</span> <span class="n">Singleton</span> <span class="o">=</span> <span class="n">Singleton</span> <span class="p">{</span> <span class="n">state</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>

<span class="nd">#[inline(never)]</span>
<span class="k">fn</span> <span class="nf">get_singleton</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="n">SINGLETON</span><span class="nf">.get</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>汇编如下：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">__ZN16unsafe_staticmut13get_singleton17h1dc92cfabd31dd96E:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	leaq	__ZN16unsafe_staticmut9SINGLETON17hff7110e0d2e7f2bcE(%rip), %rdi
	popq	%rbp
	jmp	__ZN17mutable_singleton9Singleton3get17h6fcf1a0fa3cd6caeE
	.cfi_endproc
</span></code></pre></div></div>

<p>检查的代码也消失了。执行时间看起来也不错：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run <span class="nt">--release</span> <span class="nt">--bin</span> unsafe_staticmut
<span class="go">   Compiling mutable-singleton v0.1.0 (/Users/tao/Projects/naive-rust-examples/mutable-singleton)
    Finished release [optimized] target(s) in 0.99s
     Running `target/release/unsafe_staticmut`
14292512616797437954
Time: 2706 ms
</span></code></pre></div></div>

<h3 id="未定义行为">未定义行为</h3>

<p>「每次调用都要套个 unsafe 好麻烦啊，能不能直接 <code class="language-plaintext highlighter-rouge">static SINGLETON</code> 然后 unsafe 以 <code class="language-plaintext highlighter-rouge">&amp;self</code> 修改 <code class="language-plaintext highlighter-rouge">self.state</code>？」</p>

<p>似乎我们可以这么实现：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_unsafe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.next_state</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">sptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.state</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u64</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">u64</span><span class="p">;</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="n">sptr</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">state</span>
<span class="p">}</span>
</code></pre></div></div>

<p>强硬把 const 指针转换成可变指针，然后写入数据。然后：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">SINGLETON</span><span class="p">:</span> <span class="n">Singleton</span> <span class="o">=</span> <span class="n">Singleton</span> <span class="p">{</span> <span class="n">state</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>

<span class="nd">#[inline(never)]</span>
<span class="k">fn</span> <span class="nf">get_singleton</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="n">SINGLETON</span><span class="nf">.get_unsafe</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>执行结果看起来也……：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>cargo run <span class="nt">--release</span> <span class="nt">--bin</span> unsafe_ub
<span class="go">    Finished release [optimized] target(s) in 0.00s
     Running `target/release/unsafe_ub`
[1]    19442 bus error  cargo run --release --bin unsafe_ub
</span></code></pre></div></div>

<p>算了 😅，还是写个宏吧。</p>

<p>这里要注意的是：</p>

<ol>
  <li>
<code class="language-plaintext highlighter-rouge">static</code> 分配的内存空间（很可能）不可写。</li>
  <li>就算内存空间可写，把不可变引用转换成可变的指针然后写东西的行为是未定义的。这代表可能换个环境、换个编译器版本，程序的行为就变了。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">UnsafeCell</code> 是内部可变性的基础结构，但是这里也没法用它，因为它取消了 <code class="language-plaintext highlighter-rouge">Sync</code> trait 的实现，但是 <code class="language-plaintext highlighter-rouge">static</code> 要求内部元素可以跨线程。</p>

<h3 id="最后的作业">最后的作业</h3>

<p>（2022/5/17 added）</p>

<p>前面提到的方法的问题是，<code class="language-plaintext highlighter-rouge">static mut</code> 赋的右值必须是 <code class="language-plaintext highlighter-rouge">const</code>，但是你想使用的结构不一定能在编译期就初始化好：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 编译不通过！</span>
<span class="k">use</span> <span class="nn">rand</span><span class="p">::</span><span class="nn">rngs</span><span class="p">::</span><span class="n">SmallRng</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">rand</span><span class="p">::</span><span class="n">SeedableRng</span><span class="p">;</span>

<span class="c">// 因为 seed_from_u64 不是 const fn</span>
<span class="c">// 所以即使「看起来」这个随机数生成器能够在编译期推断出结构的值</span>
<span class="c">// 那也不行</span>
<span class="k">static</span> <span class="k">mut</span> <span class="n">RNG</span><span class="p">:</span> <span class="n">SmallRng</span> <span class="o">=</span> <span class="nn">SmallRng</span><span class="p">::</span><span class="nf">seed_from_u64</span><span class="p">(</span><span class="mi">20380119</span><span class="p">);</span>
</code></pre></div></div>

<p>我不想手写随机数生成器，所以得去找点别的办法。可以观察到，一个固定长度的数组是可以的：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">mut</span> <span class="n">ARRAY</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">23</span><span class="p">];</span>
</code></pre></div></div>

<p>而且我们可以在编译期获得 <code class="language-plaintext highlighter-rouge">SmallRng</code> 结构体的大小：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">SMALLRNG_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SmallRng</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div>

<p>所以我交上去的作业就长这样：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">SMALLRNG_SIZE</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SmallRng</span><span class="o">&gt;</span><span class="p">();</span>

<span class="k">struct</span> <span class="n">Lrng</span> <span class="p">{</span>
    <span class="n">rng</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="n">SMALLRNG_SIZE</span><span class="p">],</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Lrng</span> <span class="p">{</span>
    <span class="c">// 把初始化的事情放 main() 最开始做</span>
    <span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// 拿到 rng 可变指针，硬说它是 SmallRng 的可变指针</span>
        <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.rng</span><span class="nf">.as_mut_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">SmallRng</span><span class="p">;</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c">// std::ptr::write 和直接 *ptr = xxx 应该都行</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nf">write</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="nn">SmallRng</span><span class="p">::</span><span class="nf">from_entropy</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">gen_range</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">rng</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c">// std::ptr::read 做的事情事实上是……bitwise copy</span>
            <span class="c">// 因为每次生成随机数都需要修改 rng 的内部状态，所以不能这么写，</span>
            <span class="c">// 否则每次返回的相同范围的「随机数」都是一样的（</span>
            <span class="c">// std::ptr::read(&amp;self.rng as *const [u8; SMALLRNG_SIZE] as *const SmallRng)</span>
            <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.rng</span><span class="nf">.as_mut_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">SmallRng</span><span class="p">;</span>
            <span class="c">// 对指针解引用之后返回 "rng" 的可变引用</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="o">*</span><span class="n">ptr</span>
        <span class="p">};</span>
        <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">high</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">mut</span> <span class="n">RNG</span><span class="p">:</span> <span class="n">Lrng</span> <span class="o">=</span> <span class="n">Lrng</span> <span class="p">{</span>
    <span class="n">rng</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">SMALLRNG_SIZE</span><span class="p">],</span>
<span class="p">};</span>

<span class="nd">macro_rules!</span> <span class="n">gen_range</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$high:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">RNG</span><span class="nf">.gen_range</span><span class="p">(</span><span class="nv">$high</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// 初始化</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">RNG</span><span class="nf">.init</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>于是搞定。（当然了，生产环境不要写出这种代码，我只是糊个作业才这么做的）</p>

<h1 id="后记">后记</h1>

<p>一门语言只有真正去使用它才有机会掌握，不管是自然语言还是编程语言都是如此。多写、多搜索，尝试理解，完成项目之后别忘了用 <code class="language-plaintext highlighter-rouge">cargo clippy</code> 和 <code class="language-plaintext highlighter-rouge">cargo fmt</code> 检查代码风格。</p>

<p>另外我的草稿是在 Notion 上写的，但是它的性能真的太拉垮了：文档一变长，拼音敲完之后按空格，要将近十秒才能上屏，我下次还是直接用 VS Code 写 markdown 得了。</p>

<p>最后，感谢 <a href="https://github.com/myl7" class="user-mention">@myl7</a> 和 <a href="https://github.com/zzh1996" class="user-mention">@zzh1996</a> 对本文初稿提供的建议。以上的内容由于我个人水平限制，可能存在一定的偏差，也欢迎指出其中的错误。</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>emmm 事实上，可以肯定 Rust 开发组里有《魔法少女小圆》的忠实粉丝。去 <a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a> 里搜索看看就能看到<a href="https://github.com/rust-lang/rust/search?q=madoka">测试代码里有多少 madoka</a> 了。以及在 17 年的时候，甚至<a href="https://web.archive.org/web/20170606180621/https://doc.rust-lang.org/error-index.html">在错误 E0432 的解释</a>里也有 <code class="language-plaintext highlighter-rouge">homura::Madoka</code>（当然现在没有了）。我写的时候一直想玩这个梗，终于在这里用上了（ <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

  </div>

  
    <div class="post-comments" itemprop="comment">
      <hr>
<h3>Comments</h3>
<p id="comment_darkmode_warning" style="display: none;">Note: Disqus 完整评论组件不以暗黑模式显示。</p>
<div id="disqus_thread"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqusjs.css">
<script src="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqus.js"></script>
<script>
// https://blog.skk.moe/post/prevent-disqus-from-slowing-your-site/
function loadDisqus() {
    var dsqjs = new DisqusJS({
        shortname: 'taokyblog',
        siteName: 'taoky\'s blog',
        // identifier: '',
        // url: '',
        // title: '',
        api: '//blog.taoky.moe/api/',
        apikey: 'L3W1Q35kDbi2ZGTV2iEfZ8SIksrYf847Ft0ufGon9ye1PTVxG902wO3FtIUq4wgO',
        nocomment: '无评论.',
        admin: 'taoky',
        adminLabel: 'taoky'
    });
}

// 通过检查 window 对象确认是否在浏览器中运行
var runningOnBrowser = typeof window !== "undefined";
// 通过检查 scroll 事件 API 和 User-Agent 来匹配爬虫
var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
// 检查当前浏览器是否支持 IntersectionObserver API
var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;

// 一个小 hack，将耗时任务包裹在 setTimeout(() => { }, 1) 中，可以推迟到 Event Loop 的任务队列中、等待主调用栈清空后才执行，在绝大部分浏览器中都有效
// 其实这个 hack 本来是用于优化骨架屏显示的。一些浏览器总是等 JavaScript 执行完了才开始页面渲染，导致骨架屏起不到降低 FCP 的优化效果，所以通过 hack 将耗时函数放到骨架屏渲染完成后再进行。
setTimeout(function () {
  if (!isBot && supportsIntersectionObserver) {
    // 当前环境不是爬虫、并且浏览器兼容 IntersectionObserver API
    var disqus_observer = new IntersectionObserver(function(entries) {
      // 当前视窗中已出现 Disqus 评论框所在位置
      if (entries[0].isIntersecting) {
        // 加载 Disqus
        loadDisqus();
        // 停止当前的 Observer
        disqus_observer.disconnect();
      }
    }, { threshold: [0] });
    // 设置让 Observer 观察 #disqus_thread 元素
    disqus_observer.observe(document.getElementById('disqus_thread'));
  } else {
    // 当前环境是爬虫、或当前浏览器其不兼容 IntersectionObserver API
    // 直接加载 Disqus
    loadDisqus();
  }
}, 1);

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
// (function() { // DON'T EDIT BELOW THIS LINE
// var d = document, s = d.createElement('script');
// s.src = 'https://taokyblog.disqus.com/embed.js';
// s.setAttribute('data-timestamp', +new Date());
// (d.head || d.body).appendChild(s);
// })();
</script>
<noscript>Disqus comment requires JavaScript.</noscript>
    </div>
  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Author: taoky - Subscribe via <a href="https://blog.taoky.moe/feed.xml">RSS</a>
<br>
License: <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议（CC-BY-NC-SA 4.0）</a>
    </p>

  </div>

</footer>


  </body>

</html>
