<!DOCTYPE html>
<html lang="zh">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>一点碎碎念和笔记：统计外部程序最大内存使用量的实现</title>
  <meta name="description" content="故事的背景是：这周我在用 Rust 写今年 Advent of Code 的题目。全部完成之后，我想写个程序统一统计一下我写的程序的运行时间和最大占用内存。">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://blog.taoky.moe/2023-01-01/shattered-notes-max-ram-usage.html">
  
  
  <link rel="alternate" type="application/rss+xml" title="taoky&#39;s blog" href="https://blog.taoky.moe/feed.xml">

  <link rel="stylesheet" href="/assets/typo.css">
<link rel="stylesheet" href="/assets/fonts.css">

  <link href="/assets/fonts/bitter.css" rel="stylesheet">
  
  
  
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-44647340-1', 'auto');
      ga('send', 'pageview');
    </script>
  


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">taoky&#39;s blog</a>

    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path
              d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>
      <div class="trigger">
        
        
        <a class="page-link" href="/about/">About</a>
        
        
        <a class="page-link" href="/archives/">Archives</a>
        
        
        <a class="page-link" href="/projects/">Projects</a>
        
        
        <a class="page-link" href="https://www.taoky.moe/TAsterisk">TA*</a>
        
        
        <a class="page-link" href="https://github.com/taoky">GitHub</a>
        
      </div>
    </nav>

  </div>

</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post typo" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">一点碎碎念和笔记：统计外部程序最大内存使用量的实现</h1>
    
    <p class="post-meta"><time datetime="2023-01-01T16:00:00+00:00" itemprop="datePublished">Jan 1, 2023</time> •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/tech/">tech</a>
      
    
      
    
  


 •
  
    
    
      
    
      
    
      
    
      
        <a href="/tags/linux/">Linux</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/cgroups/">cgroups</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/kernel/">kernel</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  
  <div class="user-toc">
    <h3>TOC | 目录</h3>
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#cgroups">Cgroups</a>
<ul>
<li class="toc-entry toc-h3"><a href="#基本结构">基本结构</a>
<ul>
<li class="toc-entry toc-h4"><a href="#小插曲cgroup-到底是怎么统计内存占用最大值的">小插曲：Cgroup 到底是怎么统计内存占用最大值的？</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#subtree_control-与-no-internal-processes-rule">subtree_control 与 “No internal processes” rule</a></li>
<li class="toc-entry toc-h3"><a href="#委派delegation">委派（Delegation）</a></li>
<li class="toc-entry toc-h3"><a href="#实现">实现</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#getrusage2">getrusage(2)</a>
<ul>
<li class="toc-entry toc-h3"><a href="#实现-1">实现</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#总结">总结</a></li>
</ul>
  </div>
  

  <div class="post-content" itemprop="articleBody">
    <p>故事的背景是：这周我在用 Rust 写<a href="https://adventofcode.com/2022/">今年 Advent of Code</a> 的题目。全部完成之后，我想写个程序统一统计一下我写的程序的运行时间和最大占用内存。</p>

<p>运行时间的计算很简单，但是最大占用内存怎么处理呢？最简单的办法是轮询 <code class="language-plaintext highlighter-rouge">/proc/&lt;PID&gt;/statm</code>，就能拿到程序占用的 RSS（Resident set size），或者如果要把被换出到 swap 的页也算进去的话，就用慢一点但是更精确的 <code class="language-plaintext highlighter-rouge">/proc/&lt;PID&gt;/smaps</code>（Linux 2.6.14+）或者 <code class="language-plaintext highlighter-rouge">/proc/&lt;PID&gt;/smaps_rollup</code>（<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=493b0e9d945fa9dfe96be93ae41b4ca4b6fdb317">Linux 4.14+</a>）：像 htop 这样的工具在 Linux 下获取每个进程的信息就是用读取 procfs 内容的方式实现的。（参考 <a href="https://man7.org/linux/man-pages/man5/proc.5.html">proc(5)</a>）</p>

<p>虽然对于我手头要测试的简单算法程序来讲，这么做够用了，但是这么做有两个问题：如果每次轮询的间隔太短，那么有一个 CPU 就会被吃满；如果每次轮询的间隔太长，那么记录得到的最大值就不准确。并且读取文件（特别是 smaps）似乎还会在 kernel 里有额外的<a href="https://elixir.bootlin.com/linux/v6.1.1/source/fs/proc/task_mmu.c#L634">锁</a>的开销。</p>

<p>所以我的第一反应是：把要跑的进程放进 cgroups 里面应该就行？这样让内核去帮我统计最大内存使用量就行了。为了减少麻烦，以下不考虑 swap 的问题。</p>

<h2 id="cgroups">Cgroups</h2>

<p>如果简单看过 <a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">cgroups(7)</a> 就能知道 cgroups 有两个版本：v1 和 v2。目前来讲，绝大多数的 Linux 发行版都在使用 systemd，cgroups 文件系统的挂载处理也由 systemd 完成。<a href="https://github.com/systemd/systemd/blob/main/docs/CGROUP_DELEGATION.md#three-different-tree-setups-">Systemd 提供了三种模式</a>：</p>

<ul>
  <li>Unified: 只有 v2；</li>
  <li>Legacy: 只有 v1；</li>
  <li>Hybrid: 同时挂载 v1 和 v2，v2 挂载到 <code class="language-plaintext highlighter-rouge">/sys/fs/cgroup/unified</code>。</li>
</ul>

<p>考虑到现在大多数 Linux 发行版已经在使用 unified 模式，所以接下来默认只考虑 cgroups v2，并且假设其挂载在 <code class="language-plaintext highlighter-rouge">/sys/fs/cgroup</code>。</p>

<h3 id="基本结构">基本结构</h3>

<p>Cgroups 的结构是一棵树。我们可以看一下这棵树长什么样子：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>tree <span class="nt">-d</span>                                                                                                      
<span class="c">.
</span><span class="go">├── dev-hugepages.mount
├── dev-mqueue.mount
├── init.scope
├── machine.slice
├── sys-fs-fuse-connections.mount
├── sys-kernel-config.mount
├── sys-kernel-debug.mount
├── sys-kernel-tracing.mount
├── system.slice
│   ├── accounts-daemon.service
│   ├── bluetooth.service
│   ├── bolt.service
│   ├── colord.service
│   ├── com.system76.Scheduler.service
│   ├── dbus.service
│   ├── docker.service
│   ├── docker.socket
│   ├── flatpak-system-helper.service
│   ├── fwupd.service
│   ├── gdm.service
│   ├── home.mount
│   ├── libvirtd.service
│   ├── NetworkManager.service
│   ├── nix-daemon.service
│   ├── opt.mount
│   ├── polkit.service
│   ├── rtkit-daemon.service
│   ├── systemd-journald.service
│   ├── systemd-logind.service
│   ├── systemd-machined.service
│   ├── systemd-timesyncd.service
│   ├── systemd-udevd.service
│   │   └── udev
│   ├── system-getty.slice
│   ├── system-modprobe.slice
│   ├── system-systemd\x2dbacklight.slice
│   ├── system-systemd\x2dcoredump.slice
│   ├── tmp.mount
│   ├── udisks2.service
│   ├── upower.service
│   ├── var.mount
│   ├── virtlogd.service
│   └── wpa_supplicant.service
└── user.slice
    └── user-1000.slice
        ├── session-10.scope
        ├── session-13.scope
        ├── session-7.scope
        └── user@1000.service
            ├── app.slice
            │   ├── app-flatpak-sh.cider.Cider-1174161.scope
            │   ├── app-flatpak-sh.cider.Cider-1174198.scope
            │   ├── app-gnome-firefox-1167395.scope
            │   ├── app-gnome-org.fcitx.Fcitx5-1165435.scope
            │   ├── app-gnome-org.gnome.eog-1016712.scope
            │   ├── app-gnome-org.gnome.Lollypop-1200452.scope
            │   ├── app-gnome-org.gnome.SettingsDaemon.DiskUtilityNotify-1165402.scope
            │   ├── app-gnome-org.gnome.Software-1165439.scope
            │   ├── app-gnome-org.kde.konsole-1167995.scope
            │   ├── app-gnome-org.kde.konsole-135967.scope
            │   ├── app-gnome-org.kde.konsole-939402.scope
            │   ├── app-gnome-thunderbird-1166260.scope
            │   ├── app-gnome\x2dsession\x2dmanager.slice
            │   │   └── gnome-session-manager@gnome.service
            │   ├── app-org.gnome.Terminal.slice
            │   ├── dbus.socket
            │   ├── dconf.service
            │   ├── evolution-addressbook-factory.service
            │   ├── evolution-calendar-factory.service
            │   ├── evolution-source-registry.service
            │   ├── flatpak-portal.service
            │   ├── flatpak-session-helper.service
            │   ├── gnome-keyring-daemon.service
            │   ├── gnome-session-monitor.service
            │   ├── obex.service
            │   ├── xdg-desktop-portal-gnome.service
            │   └── xdg-desktop-portal-gtk.service
            ├── background.slice
            │   └── tracker-miner-fs-3.service
            ├── init.scope
            └── session.slice
                ├── at-spi-dbus-bus.service
                ├── dbus.service
                ├── gvfs-afc-volume-monitor.service
                ├── gvfs-daemon.service
                ├── gvfs-goa-volume-monitor.service
                ├── gvfs-gphoto2-volume-monitor.service
                ├── gvfs-metadata.service
                ├── gvfs-mtp-volume-monitor.service
                ├── gvfs-udisks2-volume-monitor.service
                ├── org.gnome.SettingsDaemon.A11ySettings.service
                ├── org.gnome.SettingsDaemon.Color.service
                ├── org.gnome.SettingsDaemon.Datetime.service
                ├── org.gnome.SettingsDaemon.Housekeeping.service
                ├── org.gnome.SettingsDaemon.Keyboard.service
                ├── org.gnome.SettingsDaemon.MediaKeys.service
                ├── org.gnome.SettingsDaemon.Power.service
                ├── org.gnome.SettingsDaemon.PrintNotifications.service
                ├── org.gnome.SettingsDaemon.Rfkill.service
                ├── org.gnome.SettingsDaemon.ScreensaverProxy.service
                ├── org.gnome.SettingsDaemon.Sharing.service
                ├── org.gnome.SettingsDaemon.Smartcard.service
                ├── org.gnome.SettingsDaemon.Sound.service
                ├── org.gnome.SettingsDaemon.UsbProtection.service
                ├── org.gnome.SettingsDaemon.Wacom.service
                ├── org.gnome.SettingsDaemon.XSettings.service
                ├── org.gnome.Shell@wayland.service
                ├── pipewire-pulse.service
                ├── pipewire.service
                ├── wireplumber.service
                ├── xdg-desktop-portal.service
                ├── xdg-document-portal.service
                └── xdg-permission-store.service
</span></code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">/sys/fs/cgroup</code> 下面的每个目录（包括它本身）都是 cgroups 树的一个节点，每个节点都可以进行相关的设置（但是不仔细读文档的话会遇到坑）。节点内部的文件则用来控制这个节点的行为，例如，<code class="language-plaintext highlighter-rouge">cgroup.procs</code> 就包含这个节点控制的进程的 PID。</p>

<p>默认情况下，cgroups 树只有根节点本身，其 <code class="language-plaintext highlighter-rouge">cgroup.procs</code> 包含了系统的全部进程，但是由于 systemd 的存在，它会创建一些例如 <code class="language-plaintext highlighter-rouge">user.slice</code> 的子节点，并且将进程都移动到自己管理的 cgroup 节点中，所以如果 <code class="language-plaintext highlighter-rouge">cat /sys/fs/cgroup/cgroup.procs</code>，可以发现里面只有一部分进程（比如说内核进程）。</p>

<p>我们也可以创建自己的节点：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span><span class="nb">cd</span> /sys/fs/cgroup
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">sleep </span>1d &amp;
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">jobs</span>
<span class="go">Job     Group   CPU     State   Command
1       1202475 0%      running sleep 1d &amp;
</span><span class="gp">&gt;</span><span class="w"> </span><span class="nb">grep </span>1202475 <span class="k">**</span>/cgroup.procs  <span class="c"># bash 可能需要先 shopt -s globstar</span>
<span class="go">user.slice/user-1000.slice/user@1000.service/app.slice/app-gnome-org.kde.konsole-1167995.scope/cgroup.procs:1202475
</span><span class="gp">&gt;</span><span class="w"> </span><span class="nb">sudo</span> <span class="nt">-i</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">cd</span> /sys/fs/cgroup
<span class="gp">#</span><span class="w"> </span><span class="nb">mkdir test</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">cd test</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">ls</span>
<span class="go">cgroup.controllers      cpuset.mems.effective     io.bfq.weight        memory.reclaim
cgroup.events           cpu.stat                  io.latency           memory.stat
cgroup.freeze           cpu.uclamp.max            io.low               memory.swap.current
cgroup.kill             cpu.uclamp.min            io.max               memory.swap.events
cgroup.max.depth        cpu.weight                io.pressure          memory.swap.high
cgroup.max.descendants  cpu.weight.nice           io.prio.class        memory.swap.max
cgroup.pressure         hugetlb.1GB.current       io.stat              memory.zswap.current
cgroup.procs            hugetlb.1GB.events        io.weight            memory.zswap.max
cgroup.stat             hugetlb.1GB.events.local  irq.pressure         misc.current
cgroup.subtree_control  hugetlb.1GB.max           memory.current       misc.events
cgroup.threads          hugetlb.1GB.numa_stat     memory.events        misc.max
cgroup.type             hugetlb.1GB.rsvd.current  memory.events.local  pids.current
cpu.idle                hugetlb.1GB.rsvd.max      memory.high          pids.events
cpu.max                 hugetlb.2MB.current       memory.low           pids.max
cpu.max.burst           hugetlb.2MB.events        memory.max           pids.peak
cpu.pressure            hugetlb.2MB.events.local  memory.min           rdma.current
cpuset.cpus             hugetlb.2MB.max           memory.numa_stat     rdma.max
cpuset.cpus.effective   hugetlb.2MB.numa_stat     memory.oom.group
cpuset.cpus.partition   hugetlb.2MB.rsvd.current  memory.peak
cpuset.mems             hugetlb.2MB.rsvd.max      memory.pressure
</span><span class="gp">#</span><span class="w"> </span><span class="nb">echo </span>1202475 <span class="o">&gt;</span> cgroup.procs
<span class="gp">#</span><span class="w"> </span><span class="nb">cd</span> ..
<span class="gp">#</span><span class="w"> </span><span class="nb">cat </span>user.slice/user-1000.slice/user@1000.service/app.slice/app-gnome-org.kde.konsole-1167995.scope/cgroup.procs | <span class="nb">grep </span>1202475
<span class="gp">#</span><span class="w"> </span><span class="nb">cat test</span>/cgroup.procs | <span class="nb">grep </span>1202475
<span class="go">1202475
</span></code></pre></div></div>

<p>可以看到，我们创建了一个 <code class="language-plaintext highlighter-rouge">test</code> 节点，然后将 <code class="language-plaintext highlighter-rouge">sleep 1d</code> 这个进程从 <code class="language-plaintext highlighter-rouge">user.slice/user-1000.slice/user@1000.service/app.slice/app-gnome-org.kde.konsole-1167995.scope</code> <strong>移动</strong>到了 <code class="language-plaintext highlighter-rouge">test</code> 中，之后就可以做操作了。</p>

<p>看起来 <code class="language-plaintext highlighter-rouge">memory.peak</code> 是我们要的东西……？（备注：<code class="language-plaintext highlighter-rouge">memory.peak</code> 其实<a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/memcontrol.c#L6323">读取的是 cgroup 组内 memory 的 “watermark”</a>）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; cat /sys/fs/cgroup/test/memory.peak
0
</code></pre></div></div>

<p>诶，可能是因为 <code class="language-plaintext highlighter-rouge">sleep</code> 一直在睡觉吧，加个 <code class="language-plaintext highlighter-rouge">python</code> 进去看看：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>python
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span> import os
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span> os.getpid<span class="o">()</span>
<span class="go">1203372
</span><span class="gp">&gt;</span><span class="w"> </span><span class="c"># 开个新终端</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">sudo </span>bash <span class="nt">-c</span> <span class="s1">'echo 1203372 &gt; /sys/fs/cgroup/test/cgroup.procs'</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">cat</span> /sys/fs/cgroup/test/memory.peak
<span class="go">0
</span><span class="gp">&gt;</span><span class="w"> </span><span class="c"># ehh?</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="c"># 回去看看 python</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span> x <span class="o">=</span> <span class="o">[</span>0] <span class="k">*</span> 100000
<span class="gp">&gt;</span><span class="w"> </span><span class="c"># 再跳回去</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">cat</span> /sys/fs/cgroup/test/memory.peak
<span class="go">1048576
</span></code></pre></div></div>

<p>首先可以看出来，cgroup 的 memory subsystem 只会在内存占用情况变化的时候记录信息。然后尽管 <code class="language-plaintext highlighter-rouge">sys.getsize([0] * 100000) == 800056</code>，但是 <code class="language-plaintext highlighter-rouge">memory.peak</code> 的值 <code class="language-plaintext highlighter-rouge">1048576</code> 恰好是 <code class="language-plaintext highlighter-rouge">2 ** 20</code>。观察 <code class="language-plaintext highlighter-rouge">/sys/fs/cgroup/test/memory.stat</code>，发现匿名内存占用（anon）为 802816 bytes，而缺页次数（pgfault）为 196，页为 4K，<code class="language-plaintext highlighter-rouge">802816 / 4096 = 196</code>，似乎和缺页次数也能对上。但是 <code class="language-plaintext highlighter-rouge">memory.peak</code> 实际对应了 <code class="language-plaintext highlighter-rouge">1048576 / 4096 = 256</code> 页。</p>

<h4 id="小插曲cgroup-到底是怎么统计内存占用最大值的">小插曲：Cgroup 到底是怎么统计内存占用最大值的？</h4>

<p>（Kernel version = 6.1.1）</p>

<p>我希望能够解释为什么它的值恰好是 <code class="language-plaintext highlighter-rouge">2 ** 20</code>，所以我看了一下 python 使用的系统调用：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span>strace <span class="nt">-e</span> mmap,brk python
<span class="go">// 省略
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span> x <span class="o">=</span> <span class="o">[</span>0] <span class="k">*</span> 100000
<span class="go">mmap(NULL, 802816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f76c9871000
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<p>以及简单的 C 程序测试也出现了相同的 peak 值：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// add to cgroup node now, and then input &amp; enter</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">802816</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">802816</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">114</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>把这个程序做了一些小修改后：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#define PAGESIZE 4096
</span>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"cd .. &amp;&amp; rmdir test3 &amp;&amp; mkdir test3 &amp;&amp; cd test3 &amp;&amp; echo %d &gt; cgroup.procs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// add to cgroup node now, and then input &amp; enter</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">196</span> <span class="o">*</span> <span class="n">PAGESIZE</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PAGESIZE</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">114</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我把 mm 的关于 readahead 的部分简单读了一下，在 2022 年最后一天晚上跑了测试之后，本来打算写这么一段话的：</p>

<blockquote>
  <p>（<strong>不正确的结论</strong>） <del>我在自己机器上跑了一下，发现在顺序写入的模式下，<code class="language-plaintext highlighter-rouge">mmap()</code> 产生的内存区域在首次访问缺页时会向后预取 64 页（包含它本身，大小是 256 KiB），而在写完被预取的最后一页之后，又会再向后预取 64 页，这样的话，<code class="language-plaintext highlighter-rouge">ceil(196 / 64) * 64 = 256</code>，就解释得通了。这和网络上流传的「<code class="language-plaintext highlighter-rouge">mmap()</code> 默认预读取 32 页（128 KiB），并且前后各读取 15/16 页（read-around）」的说法是不相符的。我翻了一遍 kernel mm 的源代码，没有找到 readahead pages 大小具体的设置。并且这个行为似乎也和读取/写入的 pattern 相关联，且 <code class="language-plaintext highlighter-rouge">mmap()</code> 得到的内存区域如果足够大，会被 kernel 的透明巨页处理，在访问时可能会分配 2M 的巨页。</del></p>
</blockquote>

<p>但是感觉还是怪怪的，关键是，这是<strong>匿名</strong>页，而且只做了写入操作，真的会用到 readahead 的逻辑吗？而且这个 readahead 测试出来的结果也很奇怪。简单搜索了一下，发现 kernel 的 ftrace 机制可以 trace 进程访问的内核函数，然后我试了一下，果然我的猜测是完全错误的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; sudo trace-cmd record -p function_graph -P 1280748  # 换成对应的 PID
（好了之后 Ctrl + C 结束 tracing）
&gt; sudo trace-cmd report
（以上略）
          python-1280748 [010] 840907.640742: funcgraph_entry:                   |  handle_mm_fault() {
          python-1280748 [010] 840907.640742: funcgraph_entry:        0.382 us   |    __rcu_read_lock();
          python-1280748 [010] 840907.640742: funcgraph_entry:        0.355 us   |    mem_cgroup_from_task();
          python-1280748 [010] 840907.640743: funcgraph_entry:                   |    __count_memcg_events() {
          python-1280748 [010] 840907.640744: funcgraph_entry:        1.030 us   |      cgroup_rstat_updated();
          python-1280748 [010] 840907.640745: funcgraph_exit:         1.570 us   |    }
          python-1280748 [010] 840907.640745: funcgraph_entry:        0.266 us   |    __rcu_read_unlock();
          python-1280748 [010] 840907.640746: funcgraph_entry:                   |    __handle_mm_fault() {
          python-1280748 [010] 840907.640747: funcgraph_entry:                   |      vma_alloc_folio() {
          python-1280748 [010] 840907.640747: funcgraph_entry:        0.300 us   |        __get_vma_policy();
          python-1280748 [010] 840907.640748: funcgraph_entry:        0.263 us   |        policy_nodemask();
          python-1280748 [010] 840907.640748: funcgraph_entry:        0.286 us   |        policy_node();
          python-1280748 [010] 840907.640749: funcgraph_entry:                   |        __folio_alloc() {
          python-1280748 [010] 840907.640749: funcgraph_entry:                   |          __alloc_pages() {
          python-1280748 [010] 840907.640750: funcgraph_entry:        0.263 us   |            should_fail_alloc_page();
          python-1280748 [010] 840907.640750: funcgraph_entry:        0.344 us   |            __next_zones_zonelist();
          python-1280748 [010] 840907.640751: funcgraph_entry:                   |            get_page_from_freelist() {
          python-1280748 [010] 840907.640752: funcgraph_entry:        0.496 us   |              _raw_spin_trylock();
          python-1280748 [010] 840907.640753: funcgraph_entry:        0.280 us   |              _raw_spin_unlock_irqrestore();
          python-1280748 [010] 840907.640754: funcgraph_exit:         3.391 us   |            }
          python-1280748 [010] 840907.640755: funcgraph_exit:         5.442 us   |          }
          python-1280748 [010] 840907.640755: funcgraph_exit:         6.003 us   |        }
          python-1280748 [010] 840907.640755: funcgraph_exit:         8.319 us   |      }
          python-1280748 [010] 840907.640755: funcgraph_entry:                   |      __mem_cgroup_charge() {
          python-1280748 [010] 840907.640756: funcgraph_entry:                   |        get_mem_cgroup_from_mm() {
          python-1280748 [010] 840907.640756: funcgraph_entry:        0.273 us   |          __rcu_read_lock();
          python-1280748 [010] 840907.640757: funcgraph_entry:        0.268 us   |          __rcu_read_lock();
          python-1280748 [010] 840907.640757: funcgraph_entry:        0.427 us   |          __rcu_read_unlock();
          python-1280748 [010] 840907.640758: funcgraph_entry:        0.264 us   |          __rcu_read_unlock();
          python-1280748 [010] 840907.640758: funcgraph_exit:         2.475 us   |        }
          python-1280748 [010] 840907.640759: funcgraph_entry:                   |        charge_memcg() {
          python-1280748 [010] 840907.640759: funcgraph_entry:                   |          try_charge_memcg() {
          python-1280748 [010] 840907.640759: funcgraph_entry:                   |            page_counter_try_charge() {
          python-1280748 [010] 840907.640760: funcgraph_entry:        0.291 us   |              propagate_protected_usage();
          python-1280748 [010] 840907.640760: funcgraph_entry:        0.266 us   |              propagate_protected_usage();
          python-1280748 [010] 840907.640761: funcgraph_entry:        0.274 us   |              propagate_protected_usage();
          python-1280748 [010] 840907.640762: funcgraph_entry:        0.293 us   |              propagate_protected_usage();
          python-1280748 [010] 840907.640762: funcgraph_entry:        0.276 us   |              propagate_protected_usage();
          python-1280748 [010] 840907.640763: funcgraph_entry:        0.287 us   |              propagate_protected_usage();
          python-1280748 [010] 840907.640764: funcgraph_exit:         4.314 us   |            }
          python-1280748 [010] 840907.640764: funcgraph_entry:                   |            refill_stock() {
          python-1280748 [010] 840907.640764: funcgraph_entry:                   |              __refill_stock() {
          python-1280748 [010] 840907.640765: funcgraph_entry:                   |                drain_stock() {
          python-1280748 [010] 840907.640765: funcgraph_entry:                   |                  page_counter_uncharge() {
（以下略）
</code></pre></div></div>

<p>对着 elixir 翻一遍（或者其实要很多很多遍，我其实看了几乎两天多）代码可以知道：</p>

<ul>
  <li><a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/mempolicy.c#L2166"><code class="language-plaintext highlighter-rouge">vma_alloc_folio()</code></a> 分配出了一个内存页结构。在 <a href="https://lwn.net/Articles/874684/">Linux 5.16+</a> 引入了 <a href="https://lore.kernel.org/lkml/YX4RkYNNZtO9WL0L@casper.infradead.org/">folio</a> 的概念之后，<a href="https://elixir.bootlin.com/linux/v6.1.1/source/include/linux/mm_types.h#L73"><code class="language-plaintext highlighter-rouge">struct page</code></a> 和 <a href="https://elixir.bootlin.com/linux/v6.1.1/source/include/linux/mm_types.h#L276"><code class="language-plaintext highlighter-rouge">struct folio</code></a> 就是两个指代相同东西的结构体：一个页或者一组页（compound pages）。</li>
  <li><a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/memory.c#L5004"><code class="language-plaintext highlighter-rouge">__handle_mm_fault()</code></a> 似乎没有直接调用下面的函数，但是可以找到逻辑是 -&gt; <code class="language-plaintext highlighter-rouge">handle_pte_fault()</code> -&gt; <a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/memory.c#L4060"><code class="language-plaintext highlighter-rouge">do_anonymous_page()</code></a>。<code class="language-plaintext highlighter-rouge">vma_alloc_folio()</code> 则是再被 <code class="language-plaintext highlighter-rouge">alloc_zeroed_user_highpage_movable()</code> -&gt; <code class="language-plaintext highlighter-rouge">alloc_page_vma()</code> 调用。</li>
  <li>Linux 的内存分配用的是伙伴算法，而 <code class="language-plaintext highlighter-rouge">vma_alloc_folio()</code> 的 <code class="language-plaintext highlighter-rouge">order</code> 参数在 <code class="language-plaintext highlighter-rouge">alloc_page_vma()</code> 调用的时候是 0。<code class="language-plaintext highlighter-rouge">2 ** 0 = 1</code>，代表内存分配算法会分配一页出来（尽管存在分配器里分不出 4K 的页，<a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/page_alloc.c#L2561">只能分配更大的物理内存空间</a>导致内部碎片的可能）。</li>
  <li>cgroup memory 的 peak (watermark) 在 <a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/page_counter.c#L136"><code class="language-plaintext highlighter-rouge">page_counter_try_charge()</code></a> 里更新。而对应的，<code class="language-plaintext highlighter-rouge">charge_memcg()</code> 的参数就是我们刚刚在 <code class="language-plaintext highlighter-rouge">vma_alloc_folio()</code> 里面分出来的 folio。照理来说……不应该有问题？</li>
</ul>

<p>之后没有想到什么合理的解释，这时候搜索好像看到 eBPF 可以用来 trace 内核函数，于是我装了 <code class="language-plaintext highlighter-rouge">bpftrace</code> 跑了一下：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">&gt;</span><span class="w"> </span><span class="nb">sudo </span>bpftrace <span class="nt">-e</span> <span class="s1">'kprobe:try_charge_memcg /pid == 1293555/ { printf("%u\n", arg2); }'</span>  <span class="c"># 输出 try_charge_memcg() 被对应进程使用时的第三个参数（`nr_pages`）</span>
<span class="go">Attaching 1 probe...
1
1
1
1
（略）
</span><span class="gp">&gt;</span><span class="w"> </span><span class="nb">sudo </span>bpftrace <span class="nt">-e</span> <span class="s1">'kprobe:page_counter_try_charge /pid == 1293726/ { printf("%u\n", arg1); }'</span>  <span class="c"># 重新开进程</span>
<span class="go">Attaching 1 probe...
64
64
64
64
</span><span class="gp">&gt;</span><span class="w"> </span><span class="c"># hmmm?</span>
</code></pre></div></div>

<p>最后发现 <a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/memcontrol.c#L2630"><code class="language-plaintext highlighter-rouge">try_charge_memcg()</code></a> 有个 <code class="language-plaintext highlighter-rouge">batch = max(MEMCG_CHARGE_BATCH, nr_pages)</code>，而 <code class="language-plaintext highlighter-rouge">MEMCG_CHARGE_BATCH</code> 值为 64。首次缺页的情况下，之后由于我们没有开 cgroupv1，没有 <code class="language-plaintext highlighter-rouge">memsw</code>，所以直接执行 <code class="language-plaintext highlighter-rouge">page_counter_try_charge(&amp;memcg-&gt;memory, batch, &amp;counter)</code> 给 page counter 加了 64。而第二次到后面的缺页会被 <a href="https://elixir.bootlin.com/linux/v6.1.1/source/mm/memcontrol.c#L2223"><code class="language-plaintext highlighter-rouge">consume_stock()</code></a> 处理，所以如果还在多记录的值以内，就不会再更新 page counter。</p>

<p>于是结案。</p>

<h3 id="subtree_control-与-no-internal-processes-rule"><code class="language-plaintext highlighter-rouge">subtree_control</code> 与 “No internal processes” rule</h3>

<p>对于我想实现的场景，我希望我的程序能够依次测试需要测试的程序，但是 cgroup 节点的内存统计数据不能清除，所以每个被测试程序都需要开一个新节点装进去。初看似乎这么做是可以的：被测程序的启动器在某个节点上，每次要开的时候就建立一个新的子节点，然后把被测程序放进去，跑完之后销毁子节点就行。</p>

<p>真的吗？</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">cd</span> /sys/fs/cgroup
<span class="gp">#</span><span class="w"> </span><span class="nb">mkdir test</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">cd test</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">ls</span>
<span class="go">cgroup.controllers      cpuset.mems.effective     io.bfq.weight        memory.reclaim
cgroup.events           cpu.stat                  io.latency           memory.stat
cgroup.freeze           cpu.uclamp.max            io.low               memory.swap.current
cgroup.kill             cpu.uclamp.min            io.max               memory.swap.events
cgroup.max.depth        cpu.weight                io.pressure          memory.swap.high
cgroup.max.descendants  cpu.weight.nice           io.prio.class        memory.swap.max
cgroup.pressure         hugetlb.1GB.current       io.stat              memory.zswap.current
cgroup.procs            hugetlb.1GB.events        io.weight            memory.zswap.max
cgroup.stat             hugetlb.1GB.events.local  irq.pressure         misc.current
cgroup.subtree_control  hugetlb.1GB.max           memory.current       misc.events
cgroup.threads          hugetlb.1GB.numa_stat     memory.events        misc.max
cgroup.type             hugetlb.1GB.rsvd.current  memory.events.local  pids.current
cpu.idle                hugetlb.1GB.rsvd.max      memory.high          pids.events
cpu.max                 hugetlb.2MB.current       memory.low           pids.max
cpu.max.burst           hugetlb.2MB.events        memory.max           pids.peak
cpu.pressure            hugetlb.2MB.events.local  memory.min           rdma.current
cpuset.cpus             hugetlb.2MB.max           memory.numa_stat     rdma.max
cpuset.cpus.effective   hugetlb.2MB.numa_stat     memory.oom.group
cpuset.cpus.partition   hugetlb.2MB.rsvd.current  memory.peak
cpuset.mems             hugetlb.2MB.rsvd.max      memory.pressure
</span><span class="gp">#</span><span class="w"> </span><span class="nb">mkdir </span>test2
<span class="gp">#</span><span class="w"> </span><span class="nb">cd </span>test2
<span class="gp">#</span><span class="w"> </span><span class="nb">pwd</span>
<span class="go">/sys/fs/cgroup/test/test2
</span><span class="gp">#</span><span class="w"> </span><span class="nb">ls</span>
<span class="go">cgroup.controllers  cgroup.max.depth        cgroup.stat             cpu.pressure  memory.pressure
cgroup.events       cgroup.max.descendants  cgroup.subtree_control  cpu.stat
cgroup.freeze       cgroup.pressure         cgroup.threads          io.pressure
cgroup.kill         cgroup.procs            cgroup.type             irq.pressure
</span><span class="gp">#</span><span class="w"> </span><span class="c"># 诶，怎么只剩这么点了？</span>
</code></pre></div></div>

<p>搜索就能知道要往 <code class="language-plaintext highlighter-rouge">cgroup.subtree_control</code> 里面加上 <code class="language-plaintext highlighter-rouge">memory</code> 才行。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">cd</span> ..
<span class="gp">#</span><span class="w"> </span><span class="nb">pwd</span>
<span class="go">/sys/fs/cgroup/test
</span><span class="gp">#</span><span class="w"> </span><span class="nb">echo</span> +memory <span class="o">&gt;</span> cgroup.subtree_control
<span class="gp">#</span><span class="w"> </span><span class="nb">ls </span>test2/
<span class="go">cgroup.controllers      cgroup.subtree_control  memory.events.local  memory.reclaim
cgroup.events           cgroup.threads          memory.high          memory.stat
cgroup.freeze           cgroup.type             memory.low           memory.swap.current
cgroup.kill             cpu.pressure            memory.max           memory.swap.events
cgroup.max.depth        cpu.stat                memory.min           memory.swap.high
cgroup.max.descendants  io.pressure             memory.numa_stat     memory.swap.max
cgroup.pressure         irq.pressure            memory.oom.group     memory.zswap.current
cgroup.procs            memory.current          memory.peak          memory.zswap.max
cgroup.stat             memory.events           memory.pressure
</span></code></pre></div></div>

<p>看起来很好，让我加个进程进来……</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">pwd</span>
<span class="go">/sys/fs/cgroup/test
</span><span class="gp">#</span><span class="w"> </span><span class="nb">echo </span>1297349 <span class="o">&gt;</span> cgroup.procs
<span class="go">-bash: echo: write error: Device or resource busy
</span><span class="gp">#</span><span class="w"> </span><span class="c"># ??????????????</span>
<span class="gp">#</span><span class="w"> </span><span class="c"># 删掉 test2 试试</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">rmdir </span>test2
<span class="gp">#</span><span class="w"> </span><span class="nb">echo </span>1297349 <span class="o">&gt;</span> cgroup.procs
<span class="go">-bash: echo: write error: Device or resource busy
</span><span class="gp">#</span><span class="w"> </span><span class="c"># ??????????????</span>
<span class="gp">#</span><span class="w"> </span><span class="c"># 回滚一下刚刚的操作</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-memory</span> <span class="o">&gt;</span> cgroup.subtree_control
<span class="gp">#</span><span class="w"> </span><span class="nb">echo </span>1297349 <span class="o">&gt;</span> cgroup.procs
<span class="gp">#</span><span class="w"> </span><span class="c"># 又可以了，试试再加一下 subtree_control</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">echo</span> +memory <span class="o">&gt;</span> cgroup.subtree_control
<span class="go">-bash: echo: write error: Device or resource busy
</span></code></pre></div></div>

<p>仔细读过 <code class="language-plaintext highlighter-rouge">cgroups(7)</code> 可以发现有解释（这个文档很长，所以恐怕很多人都没有耐心看完）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cgroups v2 "no internal processes" rule
    Cgroups  v2 enforces a so-called "no internal processes" rule.  Roughly
    speaking, this rule means that, with the exception of the root  cgroup,
    processes may reside only in leaf nodes (cgroups that do not themselves
    contain child cgroups).  This avoids the need to decide how  to  parti‐
    tion resources between processes which are members of cgroup A and pro‐
    cesses in child cgroups of A.
</code></pre></div></div>

<p>虽然：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">echo </span>cgroup.procs
<span class="go">1297349
</span><span class="gp">#</span><span class="w"> </span><span class="nb">mkdir </span>test2
<span class="gp">#</span><span class="w"> </span><span class="nb">ls </span>test2
<span class="go">cgroup.controllers  cgroup.max.depth        cgroup.stat             cpu.pressure  memory.pressure
cgroup.events       cgroup.max.descendants  cgroup.subtree_control  cpu.stat
cgroup.freeze       cgroup.pressure         cgroup.threads          io.pressure
cgroup.kill         cgroup.procs            cgroup.type             irq.pressure
</span><span class="gp">#</span><span class="w"> </span><span class="c"># 好像不是不行？</span>
</code></pre></div></div>

<p>这在之后有更详细的解释：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The "no internal processes" rule is in fact  more  subtle  than  stated
above.   More precisely, the rule is that a (nonroot) cgroup can't both
(1) have member processes, and  (2)  distribute  resources  into  child
cgroups—that is, have a nonempty cgroup.subtree_control file.  Thus, it
is possible for a cgroup  to  have  both  member  processes  and  child
cgroups,  but  before  controllers  can be enabled for that cgroup, the
member processes must be moved out of the cgroup  (e.g.,  perhaps  into
the child cgroups).
</code></pre></div></div>

<p>所以对于非根节点，要么开启 <code class="language-plaintext highlighter-rouge">cgroup.subtree_control</code>（默认为空），要么本身包含进程，二选一。所以模式只能设计成，在节点（比如说 <code class="language-plaintext highlighter-rouge">test</code>）内为启动器开一个单独的子节点（比如说 <code class="language-plaintext highlighter-rouge">test/0</code>），需要启动被测试程序的时候就在外面创建一个新的子节点（比如说 <code class="language-plaintext highlighter-rouge">test/1</code>），然后放进去。</p>

<p>文档中还介绍了线程模式的情况，但是我目前用不到，也没有测试过，所以不讨论。</p>

<h3 id="委派delegation">委派（Delegation）</h3>

<p>前面的测试都是在 root 下进行的，但是我希望我的程序能以非特权用户的身份执行并控制我创建的 cgroup（root 毕竟是很危险的）。这是可以做到的，将 cgroup 子树的管理权限给非特权用户的操作被文档称为「委派」，对于我们的需求来讲，用 <code class="language-plaintext highlighter-rouge">chown</code> 修改 <code class="language-plaintext highlighter-rouge">test</code> 和 <code class="language-plaintext highlighter-rouge">test.procs</code> 的所有者，使得它们可以被需要授权的用户写入就可以了（根据文档的要求，其他的接口类的文件，例如 <code class="language-plaintext highlighter-rouge">memory.high</code> 等，不应该被修改 ownership）。</p>

<p>听起来很简单？</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">pwd</span>
<span class="go">/sys/fs/cgroup/test
</span><span class="gp">#</span><span class="w"> </span><span class="nb">chown </span>taoky:taoky <span class="nb">.</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">chown </span>taoky:taoky cgroup.procs
<span class="gp">#</span><span class="w"> </span><span class="c"># 用我自己的用户试试</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">echo </span>1298886 <span class="o">&gt;</span> /sys/fs/cgroup/test/cgroup.procs
<span class="go">write: Permission denied
</span><span class="gp">&gt;</span><span class="w"> </span><span class="c"># ?????</span>
</code></pre></div></div>

<p>这是因为上面提到，写入 <code class="language-plaintext highlighter-rouge">cgroup.procs</code> 并不是单纯的「添加进程」，实际对应的操作是<strong>从别的 cgroup 节点里移动进程过来</strong>。但是这里我自己的用户没有从 root 所有的 cgroup 节点里移动进程的权限，所以失败了。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span><span class="w"> </span><span class="nb">echo </span>1226665 <span class="o">&gt;</span> /sys/fs/cgroup/test/cgroup.procs
<span class="gp">#</span><span class="w"> </span><span class="c"># 切到自己的用户</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">cd</span> /sys/fs/cgroup/test
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">mkdir </span>test2
<span class="gp">&gt;</span><span class="w"> </span><span class="c"># 我可以新创建子节点</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">echo </span>1226665 <span class="o">&gt;</span> test2/cgroup.procs
<span class="gp">&gt;</span><span class="w"> </span><span class="c"># 把进程移动到子节点里（没有开 subtree_control）</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">echo</span> +memory <span class="o">&gt;</span> cgroup.subtree_control
<span class="go">warning: An error occurred while redirecting file 'cgroup.subtree_control'
open: Permission denied
</span><span class="gp">&gt;</span><span class="w"> </span><span class="c"># 哦忘了，回去加一下</span>
<span class="gp">#</span><span class="w"> </span><span class="nb">chown </span>taoky:taoky cgroup.subtree_control
<span class="gp">#</span><span class="w"> </span><span class="c"># 切回去</span>
<span class="gp">&gt;</span><span class="w"> </span><span class="nb">echo</span> +memory <span class="o">&gt;</span> cgroup.subtree_control
<span class="gp">&gt;</span><span class="w"> </span><span class="c"># 可以了</span>
</code></pre></div></div>

<h3 id="实现">实现</h3>

<p><a href="https://github.com/taoky/adventofcode/blob/2f48038b6fda211b3c894b3eff33d32e5cacf6d8/src/resource/cgroup.rs">我用 Rust 完成了功能的实现</a>。在初始化时，如果当前用户是 root，就直接用 Rust 的文件操作 API 在 <code class="language-plaintext highlighter-rouge">/sys/fs/cgroup</code> 下创建需要的节点（而且不需要给程序本身创建子节点，因为 root 可以顺利把生成的进程从其他的节点移动过来），否则就询问用户是否以 <code class="language-plaintext highlighter-rouge">sudo</code> 权限执行初始化脚本：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 或许可以用 Polkit 那一套东西显示更好的权限申请对话框？</span>
<span class="k">fn</span> <span class="nf">sudo</span><span class="p">(</span><span class="n">script</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">explanation</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">eprint!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">explanation</span><span class="p">);</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">" Thus the following script will be run with bash by sudo:"</span><span class="p">);</span>
    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">script</span><span class="p">);</span>
    <span class="nd">eprint!</span><span class="p">(</span><span class="s">"Continue? [y/N] "</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">input</span><span class="nf">.trim</span><span class="p">()</span> <span class="o">==</span> <span class="s">"y"</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cmd</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"sudo"</span><span class="p">);</span>
        <span class="n">cmd</span><span class="nf">.args</span><span class="p">([</span><span class="s">"bash"</span><span class="p">,</span> <span class="s">"-c"</span><span class="p">,</span> <span class="n">script</span><span class="p">]);</span>
        <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cmd</span><span class="nf">.spawn</span><span class="p">()</span><span class="o">?</span><span class="nf">.wait</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">res</span><span class="nf">.success</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">anyhow</span><span class="p">::</span><span class="nd">anyhow!</span><span class="p">(</span><span class="s">"Failed to run sudo script."</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(())</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">anyhow</span><span class="p">::</span><span class="nd">anyhow!</span><span class="p">(</span><span class="s">"User cancelled."</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 糊出来的，所以脚本比较丑</span>
<span class="k">fn</span> <span class="nf">sudo_initialize_cgroup</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">uid</span> <span class="o">=</span> <span class="nn">Uid</span><span class="p">::</span><span class="nf">current</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">script</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span>
        <span class="s">r#"
set -ex
rmdir /sys/fs/cgroup/adventofcode-2022/day* || true
rmdir /sys/fs/cgroup/adventofcode-2022 || true
mkdir /sys/fs/cgroup/adventofcode-2022
chown {} /sys/fs/cgroup/adventofcode-2022
chown {} /sys/fs/cgroup/adventofcode-2022/cgroup.procs
mkdir /sys/fs/cgroup/adventofcode-2022/day0 &amp;&amp; chown {} /sys/fs/cgroup/adventofcode-2022/day0 &amp;&amp; chown {} /sys/fs/cgroup/adventofcode-2022/day0/cgroup.procs
echo "+memory" &gt; /sys/fs/cgroup/adventofcode-2022/cgroup.subtree_control
echo {} &gt; /sys/fs/cgroup/adventofcode-2022/day0/cgroup.procs
"#</span><span class="p">,</span>
        <span class="n">uid</span><span class="p">,</span>
        <span class="n">uid</span><span class="p">,</span>
        <span class="n">uid</span><span class="p">,</span>
        <span class="n">uid</span><span class="p">,</span>
        <span class="nn">Pid</span><span class="p">::</span><span class="nf">this</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span> <span class="n">in</span> <span class="nf">day_part_iterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="nd">format!</span><span class="p">(</span>
            <span class="s">"mkdir /sys/fs/cgroup/adventofcode-2022/day{}-{} &amp;&amp; chown {} /sys/fs/cgroup/adventofcode-2022/day{}-{} &amp;&amp; chown {} /sys/fs/cgroup/adventofcode-2022/day{}-{}/cgroup.procs &amp;&amp; echo 0 &gt; /sys/fs/cgroup/adventofcode-2022/day{}-{}/memory.swap.max</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">day</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">part</span>
        <span class="p">)</span>
        <span class="nf">.as_str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nf">sudo</span><span class="p">(</span><span class="n">script</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="s">"This program needs to initialize cgroupv2 for memory usage analysis. This requires root permission."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在执行程序时，需要把程序放进对应的 cgroup 节点里面。但是默认的 Rust <code class="language-plaintext highlighter-rouge">Command</code> 在 <code class="language-plaintext highlighter-rouge">spawn()</code> 之后就直接开始了，但是我们需要在实际 <code class="language-plaintext highlighter-rouge">exec()</code> 前跑我们自己的代码（其实默认情况下，Rust 会优先调用 <code class="language-plaintext highlighter-rouge">posix_spawn()</code> 而非 <code class="language-plaintext highlighter-rouge">fork()</code> 创建进程），因此需要用 unsafe 的 <code class="language-plaintext highlighter-rouge">pre_exec()</code> 来实现我们的目的：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="p">{</span>
    <span class="n">cmd</span><span class="nf">.pre_exec</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nn">OpenOptions</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
            <span class="nf">.write</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="nf">.open</span><span class="p">(</span>
                <span class="nn">Path</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">CGROUP_DIR</span><span class="p">)</span>
                    <span class="nf">.join</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"day{}-{}"</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">part</span><span class="p">))</span>
                    <span class="nf">.join</span><span class="p">(</span><span class="s">"cgroup.procs"</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="nf">.write_all</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">())</span><span class="nf">.as_bytes</span><span class="p">())</span>
            <span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>（<strong>我没有在多线程环境下测试过上面的代码</strong>！如果真的要用，可能要处理好 <code class="language-plaintext highlighter-rouge">Path::new()</code> 和 <code class="language-plaintext highlighter-rouge">format!</code> 的部分，见下。）</p>

<p><code class="language-plaintext highlighter-rouge">pre_exec()</code> 是 unsafe 的，很大程度上是因为 <code class="language-plaintext highlighter-rouge">fork()</code> 是 unsafe 的。在很多年前，有个 “safe” 的在程序执行前运行代码的接口 <code class="language-plaintext highlighter-rouge">before_exec()</code>，但是已经废弃了，<a href="https://github.com/rust-lang/rust/issues/39575">起初的原因</a>即在于 <code class="language-plaintext highlighter-rouge">fork()</code> 在多线程环境下危险的限制：</p>

<p><code class="language-plaintext highlighter-rouge">fork(2)</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  After a fork() in a multithreaded program, the child can safely call
   only  async-signal-safe  functions (see signal-safety(7)) until such
   time as it calls execve(2).
</code></pre></div></div>

<p>（这个列表也是允许在信号处理函数里面运行的库函数和系统调用的列表）</p>

<p>而这个异步信号安全函数列表有多少函数呢？大概对于我们的需求，可以开文件 <code class="language-plaintext highlighter-rouge">open(2)</code> 看一看 <code class="language-plaintext highlighter-rouge">read(2)</code> 写一写 <code class="language-plaintext highlighter-rouge">write(2)</code>，但是<strong>不能</strong>做内存地址分配 <code class="language-plaintext highlighter-rouge">malloc(3)</code>，也不能直接退出 <code class="language-plaintext highlighter-rouge">exit(3)</code>（要用 <code class="language-plaintext highlighter-rouge">_exit(2)</code> 替代）。</p>

<p>相信用过 Python multiprocessing 的同学肯定有被 <code class="language-plaintext highlighter-rouge">fork()</code> 的这个行为坑的。</p>

<p>最后的清理工作有一些小坑：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">sudo_cleanup_cgroup</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">script</span> <span class="o">=</span> <span class="s">r#"
set -ex
# move current process to root cgroup tree node
PIDS=$(&lt;/sys/fs/cgroup/adventofcode-2022/day0/cgroup.procs)
for i in $PIDS; do 
    echo $i &gt; /sys/fs/cgroup/cgroup.procs || true; 
done
rmdir /sys/fs/cgroup/adventofcode-2022/day*
rmdir /sys/fs/cgroup/adventofcode-2022
"#</span><span class="p">;</span>
    <span class="nf">sudo</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="s">"This program needs to cleanup cgroupv2 (created at the beginning). This requires root permission."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Cgroup 的节点必须要在没有子节点、也不包含任何进程的情况下才能删除。但是当 bash 执行 <code class="language-plaintext highlighter-rouge">cat /sys/fs/cgroup/adventofcode-2022/day0/cgroup.procs</code> 的时候，事实上获得的进程列表多了一个 <code class="language-plaintext highlighter-rouge">cat</code>。然后在下面写入到 <code class="language-plaintext highlighter-rouge">/sys/fs/cgroup/cgroup.procs</code> 的时候，不存在的 <code class="language-plaintext highlighter-rouge">cat</code> 就会导致报错。</p>

<p>那么用 <code class="language-plaintext highlighter-rouge">PIDS=$(&lt;/sys/fs/cgroup/adventofcode-2022/day0/cgroup.procs)</code> 呢？很不幸，这个时候 bash 会把自己裂出一份（看 strace 好像是 <code class="language-plaintext highlighter-rouge">clone(2)</code> 出来的）去读这个文件，于是得到的文件列表里还是有一个多余的进程。最后只能忽略写入到根节点 <code class="language-plaintext highlighter-rouge">cgroup.procs</code> 出现错误的情况。</p>

<h2 id="getrusage2"><code class="language-plaintext highlighter-rouge">getrusage(2)</code></h2>

<p>大概是写完之后的第二天，我想到 GNU 的 <code class="language-plaintext highlighter-rouge">time</code> 实现可以显示程序的最大占用 RSS，当时猜测可能在 Linux 下是轮询 procfs，然后去读了读代码，发现好像有个叫 <code class="language-plaintext highlighter-rouge">wait3()</code> 的东西，好像可以从里面拿出一些统计数据。</p>

<p><img src="/pictures/maxmem/kita1.jpg" alt="" /></p>

<p><em>让我翻翻文档.jpg</em> <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If rusage is not NULL, the struct rusage to which  it  points  will  be
filled  with  accounting information about the child.  See getrusage(2)
for details.
</code></pre></div></div>

<p><img src="/pictures/maxmem/kita2.jpg" alt="" /></p>

<p><em>这啥.jpg</em></p>

<p>嗯？<code class="language-plaintext highlighter-rouge">getrusage(2)</code>？让我看看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RUSAGE_CHILDREN
        Return resource usage statistics for all children of the calling
        process that have terminated and been waited for.  These statis‐
        tics  will include the resources used by grandchildren, and fur‐
        ther removed descendants, if all of the intervening  descendants
        waited on their terminated children.
...
ru_maxrss (since Linux 2.6.32)
        This is the maximum resident set size used (in kilobytes).   For
        RUSAGE_CHILDREN,  this  is  the resident set size of the largest
        child, not the maximum resident set size of the process tree.
</code></pre></div></div>

<p><img src="/pictures/maxmem/kita3.jpg" alt="" /></p>

<p><em>白写了.jpg</em></p>

<p>所以其实完全可以用 <code class="language-plaintext highlighter-rouge">getrusage(2)</code> 来做，时间（用户时间和内核时间）也顺便帮你统计好了。只不过它<a href="https://elixir.bootlin.com/linux/v6.1.1/source/kernel/sys.c#L1785">返回</a>的是所有已经<a href="https://elixir.bootlin.com/linux/v6.1.1/source/kernel/exit.c#L1062">结束</a>的子进程<a href="https://elixir.bootlin.com/linux/v6.1.1/source/kernel/exit.c#L1091">合计</a>的数据（我又去翻了内核源代码，因为一开始看成了「已经结束但是还没 wait 的进程的数据」，还特地写了一个用 <code class="language-plaintext highlighter-rouge">waitid(2)</code> <code class="language-plaintext highlighter-rouge">WNOWAIT</code> 的实现，然后发现结果怎么都不对）。所以需要先 <code class="language-plaintext highlighter-rouge">fork()</code> 出来，然后子进程 spawn 出被测进程，等被测进程结束之后 <code class="language-plaintext highlighter-rouge">getrusage(2)</code>，然后把数据传回父进程。</p>

<h3 id="实现-1">实现</h3>

<p>前面提到 <code class="language-plaintext highlighter-rouge">fork(2)</code> 在 Rust 的模型中是不安全的。对于 <code class="language-plaintext highlighter-rouge">pre_exec()</code> 来说，能够执行的闭包有一些约束（主要是 <code class="language-plaintext highlighter-rouge">'static</code>？）：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">fn</span> <span class="n">pre_exec</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">process</span><span class="p">::</span><span class="n">Command</span>
<span class="k">where</span>
    <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="n">Sync</span> <span class="o">+</span> <span class="nv">'static</span><span class="p">,</span>
</code></pre></div></div>

<p>我之前感觉 fork 的行为和 Rust 的模型是不太匹配的（即使没有 async-signal-safety 的问题）：比如说，<code class="language-plaintext highlighter-rouge">fork()</code> 之后，就可能出现两个进程同时拿着一个 <code class="language-plaintext highlighter-rouge">&amp;mut</code> 的情况，有可能导致问题——但是父进程和子进程默认不共享内存，所以可能这一点不是问题。主要可能带来麻烦的是多线程下的 <code class="language-plaintext highlighter-rouge">fork()</code> 以及有锁的情况。</p>

<p>所以现在我们需要自己 <code class="language-plaintext highlighter-rouge">unsafe { fork()? }</code> 了：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="nf">fork</span><span class="p">()</span><span class="o">?</span> <span class="p">}</span> <span class="p">{</span>
    <span class="nn">ForkResult</span><span class="p">::</span><span class="n">Parent</span> <span class="p">{</span> <span class="n">child</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">waitpid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nn">ForkResult</span><span class="p">::</span><span class="n">Child</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="c">// spawn cmd, and getrusage(), and send back metrics to parent</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">libc</span><span class="p">::</span><span class="mi">_</span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>问题的关键是，<strong>怎么实现 IPC 呢</strong>？现在写的时候想想，应该是可以用管道来处理的（而且比下面的做法要合理很多），不过之前<a href="https://github.com/taoky/adventofcode/blob/2f48038b6fda211b3c894b3eff33d32e5cacf6d8/src/resource/getrusage.rs">实际写的时候的做法</a>是：</p>

<ul>
  <li>初始化的时候用 <code class="language-plaintext highlighter-rouge">memfd_create()</code> 在内存里创建一个匿名文件；</li>
  <li><code class="language-plaintext highlighter-rouge">fork()</code> 的时候文件描述符也会一起复制，在子进程里清空文件、seek 到开头之后向文件写入数据（反正要传输的数据只要两个数字，如果发生了错误就写入错误字符串）；</li>
  <li>写完之后子进程退出，父进程顺利 <code class="language-plaintext highlighter-rouge">waitpid()</code> 之后读文件，parse 读到的字符串。</li>
</ul>

<p>也能用（主要是文件要清空和 seek 略微麻烦）。另外这种方法父进程和子进程不能直接一起写（要用 <code class="language-plaintext highlighter-rouge">flock</code>？我没有测试过它是否能应用在 memfd 上面）。</p>

<h2 id="总结">总结</h2>

<p>这么看下来，好像还是写轮询最简单（也最「安全」？毕竟因为不用管 <code class="language-plaintext highlighter-rouge">fork()</code> 而不需要 <code class="language-plaintext highlighter-rouge">unsafe</code>）。另外写代码以及写本文的时候也读了一些 kernel 的代码，以及使用了一些 tracing kernel 的工具，这是比较意外的——首先我没有料到自己真的会去翻 elixir（以及本地 <code class="language-plaintext highlighter-rouge">rg</code>），其次现在做 tracing 也比我想象的方便太多了：获取内核函数调用信息不需要我去编译一个带超大调试符号的 kernel，也不需要再找一台电脑连着来 gdb。我不太喜欢黑盒子，所以能了解 how it works 也是很有意思的。</p>

<p>另外祝各位读者 2023 新年快乐！</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>截图自《孤独摇滚》第三集，<del>建议没看的都快去看</del>。 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  
    <div class="post-comments" itemprop="comment">
      <hr />
<h3>Comments</h3>
<p id="comment_darkmode_warning" style="display: none;">Note: Disqus 完整评论组件不以暗黑模式显示。</p>
<div id="disqus_thread"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqusjs.css">
<script src="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqus.js"></script>
<script>
// https://blog.skk.moe/post/prevent-disqus-from-slowing-your-site/
function loadDisqus() {
    var dsqjs = new DisqusJS({
        shortname: 'taokyblog',
        siteName: 'taoky\'s blog',
        // identifier: '',
        // url: '',
        // title: '',
        api: '//blog.taoky.moe/api/',
        apikey: 'L3W1Q35kDbi2ZGTV2iEfZ8SIksrYf847Ft0ufGon9ye1PTVxG902wO3FtIUq4wgO',
        nocomment: '无评论.',
        admin: 'taoky',
        adminLabel: 'taoky'
    });
}

// 通过检查 window 对象确认是否在浏览器中运行
var runningOnBrowser = typeof window !== "undefined";
// 通过检查 scroll 事件 API 和 User-Agent 来匹配爬虫
var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
// 检查当前浏览器是否支持 IntersectionObserver API
var supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;

// 一个小 hack，将耗时任务包裹在 setTimeout(() => { }, 1) 中，可以推迟到 Event Loop 的任务队列中、等待主调用栈清空后才执行，在绝大部分浏览器中都有效
// 其实这个 hack 本来是用于优化骨架屏显示的。一些浏览器总是等 JavaScript 执行完了才开始页面渲染，导致骨架屏起不到降低 FCP 的优化效果，所以通过 hack 将耗时函数放到骨架屏渲染完成后再进行。
setTimeout(function () {
  if (!isBot && supportsIntersectionObserver) {
    // 当前环境不是爬虫、并且浏览器兼容 IntersectionObserver API
    var disqus_observer = new IntersectionObserver(function(entries) {
      // 当前视窗中已出现 Disqus 评论框所在位置
      if (entries[0].isIntersecting) {
        // 加载 Disqus
        loadDisqus();
        // 停止当前的 Observer
        disqus_observer.disconnect();
      }
    }, { threshold: [0] });
    // 设置让 Observer 观察 #disqus_thread 元素
    disqus_observer.observe(document.getElementById('disqus_thread'));
  } else {
    // 当前环境是爬虫、或当前浏览器其不兼容 IntersectionObserver API
    // 直接加载 Disqus
    loadDisqus();
  }
}, 1);

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
// (function() { // DON'T EDIT BELOW THIS LINE
// var d = document, s = d.createElement('script');
// s.src = 'https://taokyblog.disqus.com/embed.js';
// s.setAttribute('data-timestamp', +new Date());
// (d.head || d.body).appendChild(s);
// })();
</script>
<noscript>Disqus comment requires JavaScript.</a></noscript>
    </div>
  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Author: taoky - Subscribe via <a href="https://blog.taoky.moe/feed.xml">RSS</a>
<br>
License: <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议（CC-BY-NC-SA 4.0）</a>
    </p>

  </div>

</footer>


  </body>

</html>
